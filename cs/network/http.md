## HTTP 버전별 차이

### HTTP/1.0
HTTP/1.0은 요청할 때마다 새로운 TCP 연결을 만든다.
그 연결을 만드는 단계가 바로 3-way handshking이다.

패킷 데이터를 보낼때마다 3way handshking을 통해 연결을 맺고 4way handshaking을 통해 연결을 종료한다.

1. 3way handshking
```
클라이언트 → 서버 : SYN       
클라이언트 ← 서버 : SYN + ACK 
클라이언트 → 서버 : ACK 
```
위 과정이 끝나야 비로소 HTTP 요청(GET /index.html)을 보낼 수 있다.

2. 실제 요청 ↔ 응답
```text
클라이언트 → 서버 : HTTP 요청 (GET /)
클라이언트 ← 서버 : HTTP 응답 (HTML, 이미지 등)
```

3. 4-way handshaking
실행이 끝나면 TCP 연결을 매번 끊는다.
```text
클라이언트 → 서버 : FIN
클라이언트 ← 서버 : ACK

서버 → 클라이언트 : FIN
클라이언트 ← 서버 : ACK
```

### HTTP/1.1
가장 널리 사용되고있는 버전이다.

장점
* **keep-alive** 기본 적용되어있어 요청에 대한 연결을 일정시간 끊지않도록 되어있다.
  * 여러 요청을 같은 TCP 연결에서 처리가 가능하다.
* 기본적으로 HTTP 요청은 순차적이기 때문에 요청에 대한 응답을 받고나서야 새로운 요청을 보낸다. 하지만 HTTP 1.1부턴 응답을 기다리지 않고 요청을 연속적을 보내는 pipelining 스펙이 추가되었다.

단점
* 그러나 응답 순서는 보장되어야하기 때문에 앞의 요청을 처리하는데 많은 시간이 소요된다면 뒤의 요청들이 늦게 응답받게되는 특정 응답 지연(Head of Line Blocking)이 발생한다.
* 매 요청마다 중복되는 헤더를 보내기 때문에 비효율적이다.

### HTTP/2.0
HTTP 1.1의 성능을 개선시킨 프로토콜이다.

* 하나의 TCP 연결에서 동시에 여러 요청/응답을 동시에 처리할 수 있다.
  * 응답은 순서에 상관없이 stream으로 주고받으며 stream이 뒤섞이는 경우 stream number를 이용해 수신측에서 재조합된다.
* Header Compression - 헤더를 압축하여 중복 제거 후 전달하기 때문에 효율적이다.

## gRPC
gRPC는 **HTTP/2** 위에서 **Protobuf**라는 바이너리 포맷을 사용해
서비스 간 함수를 직접 호출하듯 통신하는 **RPC** 프레임워크

### RPC(Remote Procedure Call)
겉으로 보기엔 로컬 메서드 호출 같지만 실제로는 원격 서버에 네트워크 요청을 보내고 응답을 받아오게 된다. (내 서버 코드에서 함수를 호출하듯이 다른 서버의 함수를 호출하는 방식)
즉 네트워크 통신을 함수 호출처럼 편하게 만들어주는 개념이다.
IDL(Interface Definication Language) 기반으로 다양한 언어를 가진 환경에서도 쉽게 확장이 가능하다는 특징이 있다.

### gRPC
Google이 개발한 오픈소스 RPC 프레임워크이다.
MSA 컴포넌트간 통신하는데 주로 사용된다. 
MSA는 서비스 간 호출이 많아서 성능이 중요한데, `HTTP/2` 기반 `프로토콜 버퍼`를 중심으로 통신한다는 특징을 가지고있어 빠르고 가볍게 통신할 수 있다.

* HTTP/1.1 → 헤더 무겁고 요청/응답 반복해서 느림
* JSON → 크기가 큼(텍스트)

유연한 확장이라는 특징으로 특히 Microservice Architecture 서비스에 적합합니다.
많은 **서비스 간의 API 호출로 인한 성능 저하를 개선**할 수 있다.
gRPC에서는 아직 브라우저에서 직접 gRPC 서비스를 호출하는 것은 불가능하다.

### protocol buffer(프로토콜 버퍼), `.proto`
gRPC가 사용하는 메시지 포맷(데이터 구조 + 직렬화 방식)이다.

IDL(Interface Definition Language, 인터페이스 정의 언어)로 프로토콜 버퍼를 사용하며 한번 정의하면
Java/Kotlin/Go/Python 등 여러 언어의 코드(요청/응답 클래스, 클라이언트 스텁, 서버 인터페이스)를 자동 생성할 수 있으며 json 기반의 통신보다 더 가볍고 통신 속도가 빠르다
컴파일 타임에 서비스 간 API 계약 불일치를 코드 레벨에서 사전에 감지할 수 있다.

### 직렬화
직렬화란 데이터를 네트워크로 보낼 수 있는 바이트 형태로 바꾸는 것이다.
json은 텍스트 기반이라 크고 파싱 비용이 크지만 protobuf는 컴퓨터가 바로 해석할 수 있는 고정된 바이너리 포맷이어서 훨씬 작고 읽기가 빠르다.
```kotlin
[필드번호=1][타입=int64][값=123]
[필드번호=2][타입=int32][값=10000]
```
문자열을 파싱하지 않아도 되고 필드명도 전송하지 않아도 된다.