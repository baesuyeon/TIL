* 참고: 인프런 [Backend 멀티쓰레드 이해하고 통찰력 키우기](https://www.inflearn.com/course/backend-%EB%A9%80%ED%8B%B0%EC%93%B0%EB%A0%88%EB%93%9C-%EC%9D%B4%ED%95%B4-%ED%86%B5%EC%B0%B0%EB%A0%A5-%ED%82%A4%EC%9A%B0%EA%B8%B0)
* 참고: [Java-혼동되는-synchronized-동기화-정리](https://jgrammer.tistory.com/entry/Java-%ED%98%BC%EB%8F%99%EB%90%98%EB%8A%94-synchronized-%EB%8F%99%EA%B8%B0%ED%99%94-%EC%A0%95%EB%A6%AC)

# Process와 Thread 기본 개념
- Process
    - 실행 파일을 실행시키면 하나의 Process가 생성된다.
    - 각 Process는 독립된 메모리 공간(Code, Data, Heap, Stack)을 가진다.
- Thread
    - Process 내부에 **실행 단위**로 Thread가 만들어진다.
    - 실행시 자동으로 Main Thread가 생성된다.
    - 하나의 Process안에 여러 Thread가 존재하면 Multi-Thread 구조가 된다.
        - 모든 Thread가 종료되어야 Process가 종료된다 (Java에서는 기본적으로 Non-Daemon Thread가 살아있는 한 JVM이 종료되지 않음)
    - **Thread끼리는 메모리를 공유하지만 Process끼리는 메모리 공유가 불가능하다.**

## Thread간 메모리 공유와 제어
- 여러 Thread가 같은 메모리 자원에 동시에 접근하면 경쟁 상태(Race Condition)가 발생할 수 있다.
  이를 해결하기 위해 배타 제어가 필요하다.

1. Concurrent
    - `ConcurrentHashMap`, `CopyOnWriteArrayList` 등 Java에서 제공하는 동시성 컬렉션.
    - 내부 구현 방식에 따라 성능 차이가 존재한다.
    - Concurrent 클래스가 어떻게 구현되어있느냐에 따라 성능 저하가 발생할 수 있다.

참고) 일반 클래스도 Read는 Thread Safe한 경우가 있다.
데이터를 한 번만 쓰고 이후에는 읽기만 하는 경우에는 별도의 동기화 없이도 여러 Thread가 동시에 읽어도 안전하다.
Write를 오직 하나의 Thread에서만 수행하고 다른 Thread들은 오직 Read만 수행한다면 일반 클래스(ArrayList, HashMap)도 동기화 없이 안전하게 쓸 수 있다.
반대로 여러 Thread가 동시에 쓰기와 읽기를 반복한다면 반드시 반드시 `ConcurrentHashMap`, `Collections.synchronizedList()` 같은 동시성 제어가 필요하다.

2. Lock
    - 특정 코드 구간(=임계 영역, 크리티컬 섹션)을 한 번에 오직 하나의 Thread만 실행 가능하도록 제한
    - `synchronized`, `ReentrantLock` 등이 대표적.
    - 단점: 임계 구역 실행 시간이 길수록 성능 저하.
    - 최악의 경우에는 차라리 Single Thread가 나을 수 있다 (One Process, One Thread Architecture)


3. Lock-Free (락 없는 방식)
    - Lock을 사용하지 않고 배타 제어를 구현하는 기법
    - 원자적 연산(Atomic Operation)을 기반으로 동작
        - `AtomicInteger`, `Interlocked.Increment()`, `CAS(compare and set)` 등
    - 장점: Lock 경합이 없어 고성능 가능
    - 단점: 구현이 어렵고 복잡한 경우가 많다.

## Process간의 통신
- Process끼리는 메모리 공유가 되지 않기 때문에 통신 수단이 필요하다.
- 고급 통신 방법(Google Protobuf, Apache Avro)
    - 구조화된 바이너리 데이터 직렬화 방식
    - 필드 추가/변경 시 호환성 유지에 유리하다.
    - Json을 사용해도 되지만 스키마 변경(필드 추가 등)시 버전 관리가 애매하다.
- Redis Pub/Sub
    - 데이터를 보내려는 서버가 알아서 다른 서버에게 보내주는게 아니라 Redis에 올려놓고 알아서 다른 서버가 가져가라 라는 방식

## Why Multi-Thread?
- 장점
    - CPU 활용 극대화
    - I/O 대기 중인 Thread가 있을 때 다른 Thread가 CPU를 사용
    - 응답성 향상
    - 서버에서 동시에 여러 요청을 처리 가능

- 단점
    - 동기화 문제 (Race Condition, Deadlock 등)
    - Context Switching 비용
        - Thread 수가 많아지면 오히려 성능 저하.
        - 디버깅 난이도 증가(동시성 문제는 재현이 어렵고 원인 추적이 힘들다)

# Thread의 흐름을 컨트롤하기

## Entry Point(진입점)이란?
```java
public static void main(String[] args) {
    // 프로그램 시작 지점
}
```
- Entry Point = Process가 맨 처음 실행하는 함수
- Java의 경우 `public static void main(String[] args)` 가 Entry Point.
- 프로그램을 실행하면 OS가 main() 함수를 호출하며 Main Thread가 시작된다.
  main() 함수의 실행이 끝나면 Main Thread 종료 → Process도 종료된다.

## 새로운 Thread 생성하기
```java
class MyTask implements Runnable {
    @Override
    public void run() {
        System.out.println("스레드에서 실행되는 작업!");
    }
}

public class Main {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new MyTask());
        thread.start(); // 별도 스레드 실행
        thread.join();  // 스레드 종료까지 대기 (Blocking)
    }
}
```
## Blocking & Non-Blocking
- Blocking(바로 리턴하지 않음): 함수 호출이 끝날 때까지(모든 코드가 실행될 때까지) 제어권을 돌려주지 않는다.
  - 호출한 쪽은 결과가 나올 때까지 기다려야한다.
- Non-Blocking(바로 리턴): 함수가 작업을 마치지 않았더라도 바로 리턴된다.
  - 호출한 쪽은 제어권을 빨리 돌려받아 다른 작업을 진행할 수 있다. 

## 동기(Synchronous) & 비동기(Asynchronous)
- 동기: **호출한 함수**가 작업 완료 여부를 확인
- 비동기: **콜백 함수**가 작업 완료 여부를 확인 (Event/Callback/Promise)

## Non-Blocking 작업 완료를 알 수 있는 방법
### Polling 방식
- 일정 주기마다 상태를 직접 확인한다.
- 단점: CPU 리소스 낭비, 불필요한 대기가 발생한다.
```
while(true) {
    if (isFinish) {
        break;
    }
    Thread.sleep(1000); // 1초마다 확인
}
```

### Event(콜백) 방식
- 작업이 끝났을 때 이벤트 발생 → 등록된 콜백 함수 호출
- 장점: 불필요한 반복이 없다.
- 단점: 콜백안에 콜백이 중첩되는 콜백 지옥이 발생할 수 있다.
```
setTimeout(() => {
    console.log("작업 완료!");
}, 1000);
```

### Promise / async & await (비동기 처리의 현대적 방식)
* 참고: [[Javascript] 비동기, Promise, async, await 확실하게 이해하기](https://springfall.cc/article/2022-11/easy-promise-async-await)

```
async function checkAge(age) {
  if (age > 20) {
    return `${age} success`;
  } else {
    throw new Error(`${age} is not over 20`);
  }
}

async function main() {
  try {
    const result = await checkAge(25); // Promise 결과를 기다림
    console.log(result); // "25 success"
  } catch (error) {
    console.error(error.message);
  }

  try {
    const result = await checkAge(15);
    console.log(result);
  } catch (error) {
    console.error(error.message); // "15 is not over 20"
  }
}

main();
```
- 콜백 지옥을 해결하기 위해 Promise가 등장했고 더 나아가 async/await 문법으로 비동기 코드를 동기 코드처럼 직관적으로 작성할 수 있게 되었다.

### Java 멀티스레드 실행 흐름
```java
public class Section2 {

    public static void startUp() {
        System.out.println("Process Start!");

        // Thread 객체 만들기
        Thread thread1 = new Thread(() -> doWork());
        Thread thread2 = new Thread(() -> doWork());

        // Thread 시작
        thread1.start();
        thread2.start();

        try {
            // Thread 종료 대기
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("All done!");
    }

    private static void doWork() {
        System.out.println("Doing work...");
        try {
            Thread.sleep(1000); // 1초 대기
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Work done!");
    }

    // 실행 Entry Point
    public static void main(String[] args) {
        startUp();
    }
}
```

## 멀티스레드의 문제점
### Stale Data (오래된 데이터)
```
bool stop = false;

function A() {
  stop = true;
}

function B() {
  int counter = 0;
  
  while (stop == false) {
    counter++;
  }
}
```
각각의 CPU는 캐시를 가지고 있어서 서로 다른 스레드는 Stale Data를 읽을 수 있다.
함수 A와 함수 B가 서로 다른 스레드에서 실행된다고 가정해보자
스레드 A가 stop = true로 변경했더라도 스레드 B가 돌고 있는 CPU 코어의 캐시 값이 갱신되지 않으면 B는 여전히 false를 읽게된다.
`volatile` 키워드를 사용하면 반드시 메인 메모리에 값을 쓰거나 읽게된다.

### Atomicity (원자성)
- `i++` 연산은 원자적이지 않다.
  - 메모리에서 `i`값을 읽는다. 
  - `i`값에 1을 더한다.
  - 결과를 다시 메모리에 쓴다.
- 여러 스레드가 동시에 `i++`를 실행하면 중간 단계에서 값이 꼬일 수 있다.