## 해시함수 ✅
해시함수는 **입력을 받아 고정된 길이의 결과**를 만들어내는 연산을 의미하고 다음과 같은 성질을 갖는다.

* 입력이 같으면 출력이 같다.
* 정방향 연산(입력 → 출력)은 빠르게 수행할 수 있다.
* 역방향 연산(출력 → 입력)은 불가능하다.
* 입력이 다른 경우 다른 결과가 나온다
* 매우 드물게 입력이 다르지만 같은 결과가 나오는 경우를 “충돌"이라고 한다.

이러한 특성 때문에 해시 함수는 다음과 같은 용도로 활용된다.
1. 암호화(비밀번호 저장)
2. 해시 테이블
3. 해시 인덱스

### 암호화(비밀번호 저장)
해시 함수는 역방향 연산이 불가능하다는 성질을 이용해 웹 서비스에서 비밀번호를 안전하게 저장하는데 사용된다.

1. 사용자가 비밀번호를 입력한다.
2. 입력한 비밀번호를 해시 함수에 넣어 해시값을 생성한다.
3. 서비스는 비밀번호 원문이 아닌 해시값만 DB에 저장한다.
4. 로그인 시에도 입력된 비밀번호를 다시 해시해서 DB에 저장된 해시값과 동일한지 비교한다.
서버조차도 사용자의 실제 비밀번호를 알 수 없다.

### Salt (솔트)
Salt는 비밀번호를 해시하기 전에 함께 섞는 랜덤한 문자열이다.

Salt 없이 해시하면 동일한 비밀번호에 대해 같은 해시값이 나온다.
이 둘이 같은 비밀번호를 사용하는지가 드러나면 공격자가 미리 계산해둔 표(레인보우 테이블)를 대조하여 비밀번호를 알아낼 수 있다

```text
hash(비밀번호 + salt)
```
Salt를 통해 같은 비밀번호라도 결과가 다르게 만들 수 있어 레인보우 테이블을 무력화한다.

Salt는
* 사용자마다 랜덤하게 생성된다.
* 비밀번호 최초 저장 시 한 번 생성되고 이후에는 계속 재사용된다. (DB에 저장: user_id, password_hash, salt)
* DB에 평문으로 저장해도 문제없다.

### SHA-256 vs bcrypt
SHA-256
* 결과는 항상 256비트(=32바이트)
* 연산 속도가 매우 빠르다.
* 공격도 빠르다 → 공격자는 GPU로 초당 수십억 번 해시시도가 가능하다. 
* 데이터 무결성 체크

bcrypt
* 의도적으로 느리다.
* 공격도 느리다.
* 내부에 salt가 자동 포함되어 같은 비밀번호라도 매번 다른 결과가 나올 수 있다.
* 비밀번호 저장에 적합

## 해시테이블
해시 테이블은 <키, 값>을 쌍으로 저장하는 자료구조이다.
대표적으로 딕셔너리(Map, Dictionary) 구조가 이에 해당한다.

해시 테이블의 가장 큰 특징은 키를 이용해 값을 매우 빠르게 조회할 수 있다는 점이다.
키를 빠르게 접근 가능한 위치(배열 인덱스)로 바꾸기 위해서 **해시 함수**를 사용한다.

### 해시테이블 조회 시간 복잡도 O(1)

```text
index = hash(key) % arraySize
```

1. **Key**를 입력으로 받는다
2. **해시 함수(hash function)** 를 적용한다
3. 결과로 **배열 인덱스**가 나온다
4. 그 인덱스로 **바로 접근**한다

이 과정은 그냥 **한 번의 계산**이다.
그래서 해시 테이블 시간 복잡도는 **O(1)** 이다.
- 반복문 ❌
- 비교 ❌
- 탐색 ❌

해시 테이블 조회 시간 복잡도가 O(1)인 이유 

**(1) 주소를 한번에 계산하는 '해시 함수'**

보통 데이터를 찾을 때는 첫번째 칸부터 마지막 칸까지 뒤져야 하지만(O(n)), 해시 테이블은 **해시 함수**를 사용하여 데이터의 위치를 바로 계산한다.
* 입력: 찾고 싶은 이름 (예: "벨루가")
* 계산: 해시 함수가 "벨루가"를 숫자 '5'로 변환
* 이동: 다른 칸은 보지도 않고 곧장 5번 칸을 열어 데이터를 꺼낸다.

**(2) 배열(Array)의 특징 활용**

해시 테이블은 내부적으로 데이터를 배열에 저장한다. 배열은 인덱스만 알면 메모리상의 위치를 즉시 찾아갈 수 있는 특징이 있다

⚠️ 하지만 예외는 있다.

이론적으로는 O(1)이지만 현실에서는 아주 가끔 '해시 충돌(Collision)'이 발생할 수 있다.
이럴 때는 한칸에 데이터를 여러개 줄세워 저장해야 하므로 아주 미세하게 속도가 느려질 수 있다.