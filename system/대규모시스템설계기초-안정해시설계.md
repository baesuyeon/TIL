> 참고: 가상 면접 사례로 배우는 대규모 시스템 설계 기초 > 안전 해시 설계

수평적 규모 확장성을 위해 요청 또는 데이터를 서버에 균등하게 나누는 것이 중요하다. 이를 위해 보편적으로 해시가 사용된다. 

## 해시 키 재배치(rehash) 문제
| 캐시 키 | 해시       | 해시 % 4 (서버 인덱스) |
|------|----------|-----------------|
| key0 | 18358617 | 1               |
| key1 | 26143584 | 0               |
| key2 | 18131146 | 2               |
| key3 | 35863496 | 0               |
| key4 | 34085809 | 1               |
| key5 | 27581703 | 3               |
| key6 | 38164978 | 2               |
| key7 | 22530351 | 2               |

```
serverIndex = hash(cacheKey) % N
```

캐시 키를 어떤 서버에 저장할지 결정하기 위해 보통 해시 함수를 사용한다.
데이터가 저장되는 서버 인덱스는 캐시 키를 해싱한 값을 N(서버 개수)로 나눈 나머지가 된다.
위 식을 통해 N개의 캐시 서버가 있을 때 특정 캐시 키가 보관된 서버를 알아낼 수 있다.

예시: 서버가 4대일 때
```
serverIndex = hash(cacheKey) % 4
```
4개의 캐시 서버가 있을 때 각 캐시 키는 해시 값 % 4의 결과에 따라 서버 인덱스 0 ~ 3 중 하나에 저장된다.
이 방식은 단순하고 구현이 쉽지만 서버 수 N이 바뀌면 대부분의 캐시 키가 다른 서버로 이동하게 된다는 단점이 있다.(예: 서버 추가/삭제 시 대규모 데이터 재배치 발생)

| 캐시 키 | 해시     | 해시 % 3 (서버 인덱스) |
|------|----------|-------------------------|
| key0 | 18358617 | 0                       |
| key1 | 26143584 | 0                       |
| key2 | 18131146 | 1                       |
| key3 | 35863496 | 2                       |
| key4 | 34085809 | 1                       |
| key5 | 27581703 | 0                       |
| key6 | 38164978 | 1                       |
| key7 | 22530351 | 0                       |

특정 캐시 서버에 장애가 있어 서버 수가 줄어들거나 늘어나게되면
데이터가 없는 엉뚱한 서버에 접속하게 되고 대규모 캐시 미스가 발생하게된다.
안정 해시는 이를 해결하는 기술이다.

## 안정 해시
안정 해시는 해시 테이블의 크기가 조정될 때 평균 k(키의 수)/n(슬롯의 수)개의 키만 재배치하는 기술이다.
서버가 추가되거나 삭제될 때 재배치되는 키의 수를 최소화할 수 있다.

### 해시 공간과 해시 링
* 해시 함수 f: SHA-1
* 출력 값 범위: x0, x1, x2, .. , xn


해시 함수는 특정 값을 숫자 범위 안으로 바꿔준다.
이 숫자 공간 전체를 해시 공간이라고 한다. (모든 키가 맵핑될 수 있는 전체 숫자 범위)
SHA-1의 해시 공간 범위는 `0 ~ 2^160-1` 가 된다.

해시 공간을 직선이 아니라 동그란 원형으로 본 게 해시 링이다.

<img width="483" height="469" alt="Image" src="https://github.com/user-attachments/assets/fe6b412a-1c40-4696-9abc-f33ff4702647" />

* 서버와 키를 균등 분포 해시 함수를 사용해 해시 링에 배치한다.
* 키는 링에서 시계 방향으로 가장 가까운 서버에 할당된다.
* 서버가 추가되거나 제거되면 일부 키만 재배치된다.

해시 함수 f를 사용해서 서버들(예: A, B, C 또는 IP1, IP2, IP3)을 해시해서 링 위에 위치시킬 수 있다. (% 연산 사용 X)
캐시할 키 k0, k1, k2, k3 또한 링 위에 위치시킬 수 있다.

어떤 키가 저장되는 서버는 해당 키의 위치로부터 시계 방향으로 링을 탐색해 나가면서 만나는 첫 번째 서버다.
key0(k0)은 서버 0(s0)에 저장되고 key2(k2)는 서버2(s2)에 저장된다.

ex)
서버들(예: A, B, C)을 해시해서 링 위에 위치시킴.
hash("ServerA") = 20, hash("ServerB") = 50, hash("ServerC") = 80
hash("key1") = 45 → 링에서 **45 이후 가장 가까운 서버(B)**가 담당.

기본 접근법의 한계
<img width="448" height="425" alt="Image" src="https://github.com/user-attachments/assets/e8d51917-8c69-419f-9d51-6faa7f188718" />

* 서버가 추가되거나 삭제되는 상황을 감안할 때 파티션의 크기(인접한 서버 사이의 해시 공간)를 균등하게 유지하는게 불가능하다.
  * s2의 파티션이 다른 파티션 대비 몇 배가 커지는 상황
* 키의 균등 분포를 달성하기가 어렵다.
  * 대부분의 키는 s2에 보관될 것이다.

### 가상 노드
하나의 서버는 링 위에 여러 개의 가상 노드를 가질 수 있다.
s0 서버를 단 하나의 위치에 두는 대신 s0_0, s0_1, s0_2처럼 여러 지점에 배치할 수 있다.
가상 노드를 도입하면 s0, s1, s2 모두 링 위에 여러 개로 퍼져 있기 때문에 각 서버가 차지하는 키 공간이 훨씬 더 균등해져 특정 서버가 과도하게 큰 파티션을 차지하는 문제를 완화할 수 있다.


