> 참고: 가상 면접 사례로 배우는 대규모 시스템 설계 기초 > 키-값 저장소 설계

## 키-값 저장소
키-값 저장소로 널리 알려진것으로는 아마존 다이나모, memcached, 레디스 등이 있다.
이 저장소에 저장되는 값은 고유 식별자를 키로 가져야 한다.
키-값 쌍에서 키는 유일해야 하며 키는 일반 텍스트일 수도 있고 해시 값일 수도 있다.

다음 연산을 지원하는 키-값 저장소를 설계해보자
* put(key, value): 키-값 쌍을 저장소에 저장한다.
* get(key): 인자로 주어진 키에 매달린 값을 꺼낸다.

## 단일 서버 키-값 저장소
단일 서버에서 동작하는 기본적인 키-값 저장소는 모든 키-값 쌍을 메모리 내 해시 테이블에 보관할 수 있다.
하지만 모든 데이터를 메모리에 담는 것은 한계가 있기 때문에 다음과 같은 개선 방법이 활용된다.

* 데이터 압축: 저장 공간을 줄여 더 많은 데이터를 메모리에 적재할 수 있다.
* 메모리 + 디스크 혼합 사용: 자주 사용되는 데이터는 메모리에 유지하고, 사용 빈도가 낮은 데이터는 디스크에 저장한다.

## 분산 키-값 저장소
* 분산 시스템이 필요한 이유
1. 확장성(Scalability)
단일 서버의 CPU, 메모리, 디스크 성능에는 한계가 있다.
사용자 수나 데이터 양이 폭발적으로 늘어나면 서버를 여러 대로 나눠서 처리해야 한다.
(수억 명 요청을 단일 서버로는 감당 불가)
(단일 서버의 디스크 용량은 제한적이기 떄문에 데이터가 테라바이트(TB), 페타바이트(PB) 단위로 커지면 반드시 여러 대 서버에 분산 저장해야 한다)

2. 가용성(Availability) & 장애 대응(Fault Tolerance)
서버 한 대는 언제든 장애가 날 수 있다. (디스크 고장, 네트워크 장애, 메모리 부족 등)
분산 시스템은 여러 노드에 데이터와 요청을 분산해두므로, 일부 서버가 죽어도 서비스가 멈추지 않는다.
(카카오톡 메시지 서버 일부가 다운되어도 대화가 멈추지 않는 이유)

3. 성능(Performance) & 지연 시간(Latency) 최적화
전 세계 사용자에게 서비스를 제공할 때, 한국에서만 서버를 두면 미국/유럽 유저는 응답 속도가 느려진다.
분산 시스템을 통해 여러 지역(Region)에 서버를 배치하면 사용자 가까운 서버가 응답해 지연을 줄일 수 있다.
(CDN(Content Delivery Network) — 이미지, 동영상 서버를 세계 각지에 분산 배치)

4. 저비용(Commodity Hardware 활용)
예전에는 성능 좋은 슈퍼컴퓨터를 써야 했지만 지금은 저렴한 범용 서버를 여러 대 묶어 고성능을 내는 게 일반적이다.

Sharding → “너무 많으니까 나눠 담자” (저장 공간 문제를 해결)
Replication → “망가지면 다른 데서 대신 읽자” (서비스 지속성을 확보)
데이터를 나눠서 여러 샤드에 저장하되, 각 샤드는 일부만 복제해서 안정성을 확보할 수 있다.

키-값 쌍을 여러 서버에 분산시킬 수 있다. 
분산 시스템을 설계할 때는 `CAP 정리`를 이해하고 있어야 한다.

### CAP 정리
CAP 정리는 데이터 일관성(consistency), 가용성(availability), 파티션 감내(partition tolerance)라는
세 가지 요구사항을 동시에 만족하는 분산 시스템을 설계하는 것은 불가능하다는 이론이다.

* 데이터 일관성: 모든 클라이언트는 어느 노드에 접속하더라도 항상 동일한 데이터를 조회할 수 있어야 한다.
* 가용성: 일부 노드에 장애가 발생하더라도 클라이언트의 요청에 항상 응답할 수 있어야 한다.
* 파티션 감내: 분산 시스템은 여러 대의 서버(노드)가 네트워크로 연결되어 하나의 시스템처럼 동작한다. 
  그런데 네트워크는 완벽하지 않아서 끊기거나, 지연되거나, 특정 노드 간 통신이 불가능한 상황이 발생할 수 있다.
  이런 상황(클러스터가 서로 다른 파티션(분리된 그룹)으로 나뉘더라도)에서도 시스템이 계속 동작할 수 있어야 한다.

네트워크가 끊어졌다면 파티션 감내는 사실상 피할 수 없는 현실이므로 분산 시스템은 반드시 파티션 문제를 감내할 수 있도록 설계되어야 한다.
따라서 분산 시스템은 일관성(Consistency) vs 가용성(Availability) 중 하나를 희생해야 한다.
- CP 시스템: 파티션이 생기면, 일부 요청은 막아서라도 데이터 일관성을 유지 (ex. HBase, Zookeeper)
  - 모두가 똑같은 데이터를 보는 게 중요.
- AP 시스템: 파티션이 생겨도 응답은 주지만, 잠시 일관성이 깨질 수 있음 (ex. Cassandra, DynamoDB)
  - 요청이 오면 무조건 응답을 준다는 개념.

## 실세계의 분산 시스템
<img width="313" height="239" alt="Image" src="https://github.com/user-attachments/assets/15e23424-953c-45f7-8460-0130ec40398d" />

위와 같이 n3에 장애가 발생하여 n1, n2와 통신할 수 없는 네트워크 파티션 문제가 발생하면
n1, n2에 기록된 데이터는 n3에 전달되지 않고 n3에 기록되었으나 아직 n1, n2에 전달되지 않은 데이터가 있어 n1, n2는 오래된 사본을 갖고있을 수 있다.

* 일관성을 선택한다면
  * 세 서버 사이에 생길 수 있는 데이터 불일치 문제를 피하기 위해 n1, n2에 대해 쓰기 연산을 중단시킬 수 있다.
  * 은행 시스템은 보통 데이터 일관성을 양보하지 않는다.
  * 네트워크 파티션때문에 일관성이 깨질 수 있는 상황이 발생하면 상황이 해결될때까지 오류를 반환해야 한다.

* 가용성을 선택한다면
  * 낡은 데이터를 반환한다고 하더라도 읽기 연산을 허용하고, n1, n2는 계속 쓰기 연산을 허용한다.
  * 파티션 문제가 해결되었을 때 세 데이터를 n3에 전송한다.

## 시스템 컨포넌트
### 데이터 파티션
대규모 애플리케이션에서는 전체 데이터를 단일 서버에 모두 저장하는 것이 불가능하다.
따라서 데이터를 여러 개의 작은 파티션으로 나눈 뒤, 여러 서버에 분산 저장하는 방식이 필요하다.

이때 고려해야 할 핵심 사항은 다음과 같다
* 균등한 분산: 데이터를 여러 서버에 가능한 한 고르게 나누어 저장하여 특정 서버에 부하가 집중되지 않도록 해야 한다.
* 데이터 이동 최소화: 서버(노드)가 추가되거나 삭제될 때, 전체 데이터가 대규모로 재배치되지 않고 필요한 데이터만 최소한으로 이동할 수 있어야 한다.

안정 해시를 사용하여 데이터를 파티션할 수 있다.

### 데이터 다중화
높은 가용성과 안정성을 확보하기 위해서는 데이터를 N개 서버에 비동기적으로 다중화(replication)할 필요가 있다.
안정 해시에서는 어떤 키를 해시 링 위에 배치한 후 그 지점으로부터 시계 방향으로 순회하면서 만나는 첫 N개 서버에 데이터 사본을 보관할 수 있다. 

### 복제된 데이터의 쓰기 정책
| 전략                             | 설명                                        | 대표 시스템 |
|--------------------------------|-----------------------------------------------|----------------|
| Primary–Replica (Master–Slave) | 하나의 Primary 노드만 쓰기 허용, 다른 노드는 복제만 허용  | MySQL, MongoDB 기본 모드, Redis replication |
| Multi–Leader (or Leaderless)   | 모든 노드가 쓰기를 받을 수 있음. 이후 충돌 해결 필요       | DynamoDB, Cassandra   |
복제된 데이터가 항상 “읽기 전용(=secondary replica는 read-only)” 이라고 단정할 수는 없다

### 데이터 일관성
여러 노드에 다중화된 데이터는 적절히 동기화되어야 한다.
정족수 합의 프로토콜을 사용하면 읽기/쓰기 연산에 모두 일관성을 보장할 수 있다.

복제된 노드 수를 N이라 할 때,
* 쓰기 연산(write) 은 적어도 W개 노드로부터 “쓰기 성공” 응답을 받아야 성공으로 간주한다. (N개 중 W개 성공 → 성공으로 판단)
* 읽기 연산(read) 은 적어도 R개 노드로부터 데이터를 읽어와야 성공으로 간주한다. (N개 중 R개 응답 → 성공으로 판단)

W + R > N → 강한 일관성
요구하는 일관성 수준에 따라 W, R, N의 값을 조정할 수 있다.

### 비일관성 해소 기법 : 데이터 버저닝
분산 시스템에서는 동일한 데이터에 대해 동시에 쓰기(Write) 연산이 발생할 수 있다.
예를 들어 데이터 사본이 노드 n1, n2에 복제되어 있을 때, 두 노드 동시에 데이터 수정 연산이 이루어질 수 있다. 
이때 **벡터 시계**를 사용하면 버전 충돌을 감지하고 정리할 수 있다.

두 노드(n1, n2) 모두 쓰기를 허용하니까 “누가 더 최신인가?”를 판단해야 한다.
각 노드가 데이터를 업데이트할 때, 벡터 시계(노드 ID + 카운터)를 metadata로 데이터와 함께 저장한다.
벡터 시계를 통해 다른 노드와 비교 시
* 어떤 버전이 더 최신인지
* 동시 수정인지(conflict)

판단 가능하다.

| 버전명 | 서버 | 내용                | 벡터 시계          | 관계            |
| --- | -- | ----------------- | -------------- | ------------- |
| D1  | Sx | "사과"              | [Sx,1]         | 처음 저장된 버전     |
| D2  | Sx | "사과 🍎"           | [Sx,2]         | D1을 수정한 다음 버전 |
| D3  | Sy | "사과 🍎 + 가격정보 추가" | [Sx,2], [Sy,1] | D2를 받아 수정     |
| D4  | Sz | "사과 🍎 + 재고정보 추가" | [Sx,2], [Sz,1] | D2를 받아 수정     |

* “누가 최신인가?”를 판단하는 법

버전 Y에 포함된 모든 구성 요소의 값이 버전 X에 포함된 모든 구성요소 값보다 같거나 큰지만 보면 된다. 

ex) 
```
D2([Sx,2]) vs D3([Sx,2], [Sy,1])
```
D2([Sx,2]) vs D3([Sx,2], [Sy,1])
→ D2는 Sx=2이고, D3는 Sx=2, Sy=1이니까
D2의 모든 항목이 D3에 포함되고 작거나 같음 → D2는 D3의 ‘이전 상태’라고 볼 수 있다.

* "동시 수정인지(conflict)"를 판단하는 법
> X ≠ Y and X ⊀ Y and Y ⊀ X
> 
> → 서로 비교할 수 없음 = 충돌(conflict)

ex)
```
D3([Sx,2],[Sy,1]), D4([Sx,2],[Sz,1])
```
D3은 Sy=1이 있지만 Sz=없음, D4는 Sz=1이 있지만 Sy=없음
즉 어느 쪽이 “더 최신”이라고 단정할 수 없다. 서로 다른 서버에서 독립적으로 수정된 상황이므로 충돌이 발생한 상황이다.

클라이언트가 D3,D4를 읽으면 데이터 간 충돌이 있다는 것을 알 수 있다.
이때 직접 병합하거나(애플리케이션 로직 기반), 자동 규칙(마지막 쓰기 연산을 채택하는 방식)으로 병합 후 저장할 수 있다.
병합하는 경우 병합된 결과가 D5가 되고, 그 벡터시계는 [Sx,3], [Sy,1], [Sz,1] 처럼 세 서버의 변경 이력을 포함하게 된다.

벡터 시계는 클라이언트가 충돌 감지 및 해소 로직을 갖게되기 때문에 클라이언트 구현이 복잡해진다는 단점이 있다.

### 장애 감지 기법
분산 시스템에서는 한 서버의 장애를 단일 서버가 판단하지 않는다.
일반적으로 두 대 이상의 서버가 특정 서버 A의 장애를 보고해야 그 서버에 실제로 장애가 발생한 것으로 간주한다.

가십 프로토콜 동작 방식
1) 각 서버는 멤버십 목록(각 멤버 ID, 하트비트 카운트)을 갖고있다.
2) 각 서버는 주기적으로 자신의 하트비트 카운트를 증가시킨다.
3) 각 서버는 무작위로 선정된 노드들에게 주기적으로 자신의 멤버십 목록을 전송한다.
4) 멤버십 목록을 받은 서버는 자신의 멤버십 목록과 비교하여 더 최신인 값으로 갱신한다.
5) 특정 멤버의 하트비트 카운트 값이 지정된 시간동안 갱신되지 않으면 해당 멤버는 장애 상태로 간주한다.

장애를 감지한 후 분산 시스템은 가용성(Availability)과 일관성(Consistency) 사이에서 균형을 유지해야 한다.
이때 장애의 지속 시간과 범위에 따라 서로 다른 전략이 적용된다.

* 일시적 장애 처리
  * 엄격한 정족수 접근법
    * 읽기와 쓰기 연산을 금지한다.
  * 느슨한 정족수 접근법 
    * 해시 링에서 쓰기 연산을 수행할 W개의 건강한 서버, 읽기 연산을 수행할 R개의 건강한 서버를 고른다 (장애 서버는 무시)
  * 장애 상태인 서버로 가는 요청을 잠시 다른 서버가 맡아서 처리하고 복구되면 그동안 발생한 변경사항을 반영한다. 

* 영구 장애 처리
  * <img width="1380" height="912" alt="image" src="https://github.com/user-attachments/assets/cc8fa4b9-9d43-4e23-9fcc-6efb064e19e0" />
  * 머클 트리를 사용해 일관성이 망가진 데이터를 탐지할 수 있다. (해시 값을 비교하는 방식)

```text
    h(AB)
   /     \
 h(A)   h(B)
```

