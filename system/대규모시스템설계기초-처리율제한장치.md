> 참고: 가상 면접 사례로 배우는 대규모 시스템 설계 기초 > 처리율 제한 장치의 설계

## 처리율 제한 장치란?
처리율 제한 장치: 클라이언트가 보내는 트래픽의 처리율을 제어하기 위한 장치
서버 과부하를 막을 수 있다. (봇에서 오는 트래픽이나 사용자의 잘못된 이용 패턴으로 유발된 트래픽을 걸러낼 수 있다)

ex) 
- 트위터는 3시간 동안 300개의 트윗만 올릴 수 있다.
- 구글 독스 API는 사용자당 분당 300회의 read 요청만 허용한다.

## 처리율 제한 장치를 어디에 둘까?
처리율 제한 장치를 클라이언트에 두면 -> 클라이언트 요청은 쉽게 위변조가 가능하다.

<img width="526" height="195" alt="처리율 drawio" src="https://github.com/user-attachments/assets/a183b8d8-4378-4cf5-9db6-c077adf01f14" />

처리율 제한 장치를 클라이언트나 API 서버에 두는 대신, 미들웨어를 만들고 미들웨어에서 API 서버로 가는 요청을 통제할 수 있다.
처리율 제한 장치는 보통 API 게이트웨이에 구현된다.

## 처리율 제한 아키텍처
- 얼마나 많은 요청이 접수되었는지 추적할 수 있는 카운터를 추적 대상별로 둔다.
  - 추적 대상은 사용자, IP 주소, API 엔드포인트, 서비스 단위가 될 수 있다.
- 카운터의 값이 한도를 넘어서는 경우 요청을 거부한다.
- 카운터 값은 Redis에 저장하는 것이 효율적이다.
- 처리율 제한 규칙은 설정 파일(configuration file) 형태로 디스크에 저장한다.
  - 작업 프로세스는 수시로 규칙을 디스크에서 읽어 캐시에 저장한다.
- 요청이 한도 제한에 걸리면 API는 HTTP 429(too many requests)를 클라이언트에 보낸다.
  - HTTP 헤더를 통해 더 많은 정보를 클라이언트에게 보낼 수 있다.

## 분산 환경에서의 처리율 제한 아키텍처
- 단일 서버가 아닌 분산 환경에서는 '경쟁 조건(race condition)', '동기화(synchronization)'을 고려해야 한다.

### 경쟁 조건
처리율 제한 장치는 대략 다음과 같이 동작한다.
- Redis에서 카운터의 값을 읽는다.
- counter + 1의 값이 임계치를 넘는지 본다.
- 넘지 않는다면 Redis에 보관된 카운터 값을 1만큼 증가시킨다.

여러 클라이언트가 동시에 Redis에 접근해서 같은 키를 읽고 수정하는 상황에서 발생
- 클라이언트 A, B가 동시에 counter=3 값을 읽음
- 둘다 counter+1 연산 후 Redis에 4를 저장 → Redis에는 5가 저장되어야 한다.

Redis Sorted Set 자료구조를 사용하는 방법
Sorted Set은 멤버(member)와 점수(score)를 함께 저장하는 Redis의 특수한 자료구조다.
이 자료구조는 점수를 기준으로 멤버들을 항상 정렬된 상태로 유지한다.

ex) 1분 내 10회 요청 제한
- 요청 기록: 사용자가 요청할 때마다 현재 시간을 점수로, 사용자 ID를 멤버로 하여 Sorted Set에 추가 (ZADD)
- 오래된 기록 삭제: 1분 range보다 오래된(점수가 낮은) 모든 멤버를 삭제 (ZREMRANGEBYSCORE)
- 개수 확인: 명령어로 남아있는 멤버의 수를 확인하여, 요청 횟수가 10회를 초과했는지 판단 (ZCARD)

```
ZADD key score member

ZADD ranking 100 "철수"
ZADD ranking 95 "영희"
```
`ZADD`: Sorted Set에 새로운 원소를 추가(add) 하는 명령어.

```
ZREMRANGEBYSCORE key min max

ZADD ranking 100 "철수"
ZADD ranking 95 "영희"
ZADD ranking 80 "민수"
ZADD ranking 70 "지수"
```
`ZREMRANGEBYSCORE`: 특정 점수(score) 범위에 해당하는 멤버들을 한 번에 지우는 명령어 (min, max는 삭제할 점수 구간)

```
ZCARD key
```
`ZCARD`: 멤버 개수를 반환한다 (key : 대상 Sorted Set 이름)

### 동기화 이슈
수백만 사용자를 지원하려면 한 대의 처리율 제한 장치 서버로는 충분하지 않을 수 있다.
처리율 제한 장치 서버를 여러 대 두게 되면 동기화가 필요해진다.
이를 위해 확장성이 낮은 고정 세션 대신(Sticky session) Redis와 같은 중앙 집중형 데이터를 사용할 수 있다.

## 처리율 제한 알고리즘
- 토큰 버킷 (token bucket)
- 누출 버킷 (leaky bucket)
- 고정 윈도우 카운터 (fixed window counter)
- 이동 윈도우 로그 (sliding window log)
- 이동 윈도우 카운터 (sliding window counter)

### 토큰 버킷 알고리즘
동작 방식
- 양동이(bucket) 안에 일정 개수의 토큰(token) 이 들어 있다.
- 요청 1건을 처리하려면 토큰 1개를 소비해야 한다.
- 토큰은 일정한 속도로 채워진다 (예: 초당 5개)
- 버킷이 가득 차면 더 이상 토큰은 쌓이지 않고 버려진다.
- 요청이 왔는데 토큰이 없으면 요청을 거부하거나 지연시킨다.

버킷 관리
- 통상적으로 API 마다 별도의 버킷을 둔다. 사용자마다 하루에 한 번만 포스팅을 할 수 있고, 친구는 150명까지 추가할 수 있고, 좋아요 버튼은 5번까지 누를 수 있다면 사용자마다 3개의 버킷을 두어야 한다.
- IP 주소별로 처리율 제한을 적용해야 한다면, IP 주소마다 버킷을 하나씩 할당해야 한다.
- 시스템의 처리율을 초당 10,000개로 제한하고 싶다면 모든 요청이 하나의 버킷을 공유하도록 한다.

특징
- 요청이 고정 속도로 처리되지는 않는다. 토큰이 쌓여 있는 만큼 요청을 한꺼번에 처리하기 때문에 토큰이 많을 때는 빠르게, 없을 때는 느리게 처리하여 처리율이 유동적이다.

### 누출 버킷 알고리즘
동작 방식
- 버킷(큐)에 요청이 쌓인다.
- 지정된 시간마다 큐에서 요청을 꺼내서 처리한다.

특징
- 토큰 버킷 알고리즘과 비슷하지만 요청 처리율이 고정되어 있다. 버킷에서 요청은 고정 속도로 처리된다.
- 순간적으로 몰리는 요청을 소화하지 못하고 큐에서 버려진다.

## 고정 윈도우 카운터 알고리즘
```
[ 0.0s ---------------- 1.0s ] → 5개 허용
[ 1.0s ---------------- 2.0s ] → 5개 허용
```

동작 방식
- 고정된 윈도우(1초, 1분, 1시간)를 정하고
- 각 윈도우 동안의 요청 횟수를 카운팅한다.
- 요청 수가 limit을 넘으면 윈도우 끝날 때까지 추가 요청은 차단된다.
- 새 윈로우가 시작되면 카운터가 초기화된다.

예시
- 제한: 초당 5회 요청 허용
- 요청 시퀀스
  - 0.1초 ~ 0.9초 동안 요청 5회 발생 → 모두 허용 ✅
  - 0.95초에 요청 1회 발생 → 이미 5회 도달, 차단 ❌
  - 1.0초가 되면 새로운 윈도우 시작 → 카운터 리셋 (다시 5회 가능)

활용 사례
- 로그인 시도 횟수 제한 (1분간 5회 이상 실패하면 차단)

단점
- 윈도우 경계 문제(Window Boundary Problem)가 있다.
- 예: 0.9초에 5회, 1.1초에 5회 → 2초 동안 총 10회 처리될 수 있다. (시스템에 설정된 허용치보다 처리하는 요청이 많아짐)
- 따라서 트래픽이 윈도우 경계에 몰리면 순간적으로 버스트가 허용된다.

## 이동 윈도우 로깅 알고리즘
- 새로운 요청이 들어올 때마다 정확한 타임스탬프를 로깅하고
- 현재 시각 기준으로 윈도우 크기(ex: 60초)안에 들어온 요청만 세어본다. ("최근 1분 안에 몇 개 들어왔는지"를 계산한다)
- 여기서 중요한 점은 윈도우를 12:00:00~12:01:00 같이 고정된 구간으로 보지 않고, "현재 시점에서 정확히 과거 1분"을 본다는 것이다.

단점
- 로그를 계속 저장해야 해서 메모리 비용이 크다.

## 이동 윈도우 카운터 알고리즘
<img width="602" height="335" alt="Image" src="https://github.com/user-attachments/assets/891aed3a-1928-4531-a7fd-032c029f263f" />

- 분당 7개 요청으로 제한이 걸려있을때, 이전 5분동안 5개의 요청이, 현재 1분 동안 3개의 요청이 왔을 때
- 현재 구간 카운트 + 직전 구간 카운트 일부를 가중치로 더한다.
- 현재 1분간의 요청 수 + (직전 1분간의 요청수 * 이동 윈도우와 직전 1분이 겹치는 비율)
- 현재 윈도우에 들어있는 요청은 3 + (5 * 70%) = 6.5개
  - 분당 7개 요청으로 제한이 걸려있기 때문에 ,현재 1분의 30% 시점에 도착한 신규 요청은 시스템으로 전달되지만, 그 이후에는 한도에 도달하였으므로 더 이상의 요청은 받을 수 없다.

장점
- 메모리 효율이 좋다

단점
- 근사치를 사용하여 완벽히 정확하지는 않다.
  - 직전 시간대에 도착한 요청이 균등하게 분포되어있다고 가정한 상태에서 추정치를 계산하기 때문에 다소 느슨하다.