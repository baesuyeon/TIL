> 참고: 가상 면접 사례로 배우는 대규모 시스템 설계 기초 > 사용자 수에 따른 규모 확장성

대규모 시스템 설계에서 가장 중요한 과제 중 하나는 사용자 증가에 따른 트래픽, 데이터, 요청 처리량의 증가에 어떻게 대응하느냐이다.

## 데이터베이스 선택: 관계형 vs 비관계형
비관계형 데이터베이스(NoSQL)가 적합한 경우
* 낮은 응답 지연시간(latency)이 중요할 때
* 데이터 구조가 비정형일 때 (관계형 스키마로 표현하기 어려울 때)
* 아주 많은 데이터를 저장할 필요가 있을 때

## 수직적 규모 확장 vs 수평적 규모 확장
* 수직적 규모 확장에는 한계가 있다. 한 대의 서버에 CPU나 메모리를 무한대로 증설할 방법이 없다.
* 한 대의 서버에 장애가 발생하면 서비스가 완전히 중단된다.

## 로드밸런서
```
Client ─▶ Load Balancer ─▶ [ Server1 | Server2 | Server3 ... ]
```
load balancing set에 속한 서버들에게 트래픽 부하를 고르게 분산하는 역할을 한다.
클라이언트는 서버에 직접 접속하지 않고 로드밸런서의 공개 IP 주소(public IP address)로 접속한다.

서버간 통신에는 사설 IP 주소(private IP address)가 이용된다.
사설 IP 주소는 같은 네트워크에 속한 서버 사이의 통신에만 쓰일 수 있는 IP 주소로 인터넷을 통해서는 접속할 수 없다.
로드밸런서는 웹 서버와 통신하기 위해 이 사설 주소를 이용한다.

* 서버 1, 서버2가 있다고 가정한다.
* 서버 1이 다운되면 모든 트래픽은 서버 2로 전송된다.
* 트래픽이 가파르게 증가하면 load balancing set에 더 많은 서버를 추가한다. 그러면 로드밸런서가 자동으로 트래픽을 분산한다.
대표 기술: Nginx

## 데이터베이스 다중화 (Replication)
서버가 다중화되었다고 하더라도 데이터베이스 서버가 한 대라면 병목이 발생한다.
이를 해결하기 위해 master-slave 구조의 복제(replication)을 사용한다.
쓰기 연산은 master에만 지원하고 slave는 읽기연산만 지원하여 데이터 원본은 master 서버에, 사본은 slave 서버에 저장한다.

동작 방식
* master: 쓰기 연산(INSERT, UPDATE, DELETE) 처리
* slave: 읽기 전용(SELECT) 처리
* master의 변경 사항은 주기적으로 slave로 전파

데이터베이스 다중화 이점
* 읽기 요청을 여러 slave로 분산하여 처리량이 증가한다.
* 데이터베이스 서버에 장애가 발생하더라도 데이터가 보존된다.
* 데이터베이스 서버에 장애가 발생하더라도 다른 서버에 있는 데이터를 가져와 서비스를 이어갈 수 있다.

master 데이터베이스 서버가 다운되면 slave 데이터베이스 서버가 새로운 master 서버가 된다.#
단 승격 시점에 복제 지연이 있었다면 일부 최신 데이터가 누락될 수 있다. (복구 스크립트를 통해 누락 데이터를 보정해야 한다)

최종 동작 방식
* 클라이언트는 DNS로부터 로드밸런서의 공개 IP 주소를 받는다.
* 사용자는 해당 IP 주소를 사용해 로드밸런서에 접속한다.
* 로드밸런서는 여러 서버 중 하나로 요청을 전달한다.
* 서버는 요청을 slave(읽기) 또는 master(쓰기) 데이터베이스로 전달한다.

## 캐시
캐시는 값 비싼 연산 결과나 자주 참조되는 데이터를 메모리에 임시 저장하여 데이터베이스 접근 횟수를 줄이고 응답 속도를 향상시키는 저장소이다.
애플리케이션의 성능은 데이터베이스를 얼마나 자주 호출하느냐에 따라 좌우된다.

* Cache Hit : 요청한 데이터가 캐시에 존재 → 즉시 반환 (DB 접근 불필요)
* Cache Miss : 캐시에 데이터가 없음 → DB 조회 후 결과를 캐시에 저장
* Cache Update : 원본 데이터(DB)가 변경되면 캐시 내용도 갱신 필요
* Cache Eviction : 캐시 공간이 꽉 찼을 때 오래되거나 덜 사용된 데이터 제거

### 캐시 사용이 유용한 경우
데이터의 변경 빈도는 낮지만 조회 빈도는 높은 경우, 읽기가 많은 시스템

### 캐시 설계시 주의사항
영속적으로 보관할 데이터를 캐시에 두는 것은 바람직하지 않다. 캐시 서버가 재시작되면 캐시 내의 모든 데이터는 사라진다.
캐시 메모리가 너무 작으면 데이터가 너무 자주 캐시에서 밀려나버려(eviction) 캐시의 성능이 떨어지게 된다.
DB 값이 변경되면 캐시도 갱신해야한다. 그렇지 않으면 오래된 값(stale data)이 반환될 수 있다.
TTL(Time To Live)을 설정해 오래된 데이터가 자동 삭제되도록 관리해야한다.

### 캐시 방출 정책
* LRU : 가장 오래 전에 사용된 데이터를 제거, 가장 널리 쓰이는 정책 (Redis 기본)
* LFU : 가장 사용 빈도가 낮은 데이터를 제거
* FIFO : 가장 먼저 들어온 데이터를 제거

* Redis, Memcached 등은 LRU 기반 알고리즘을 기본으로 사용하며 상황에 따라 LFU/FIFO도 설정 가능하다.

### CDN
```text
사용자 → 가까운 CDN 엣지 서버 → 원본 서버(Origin)
```
CDN은 전 세계에 분산된 서버 네트워크를 통해 정적 콘텐츠(HTML, CSS, JS, 이미지, 동영상 등)를 사용자에게 가장 가까운 위치에서 빠르게 전달하는 기술이다.
클라이언트 요청시 CDN은 요청 경로, 질의 문자열, 쿠키, 요청 헤더 등을 기반으로 캐시 여부를 판단하고, 이미 캐시된 콘텐츠라면 즉시 반환한다.
사용자는 지리적으로 가까운 CDN 서버에서 데이터를 받기 때문에 지연(latency)이 줄고 서버 부하가 감소한다.

* CDN 사용 시 고려해야 할 사항
  - 대부분의 CDN은 Third-party provider가 운영하며, 데이터 전송량(트래픽) 기준으로 과금된다.
  - 자주 요청되지 않는 콘텐츠를 캐싱하면 비용 대비 이점이 적다.

> 예시
>  
> Cloudfront에서 제공하는 URL: https://mysite.cloudfront.net/logo.jpg
> 아카마이(Akamai) CDN이 제공하는 URL: https://mysite.akamai.com/image-manager/img/logo.jpg

### 무상태(stateless) 웹 계층
무상태 웹 계층은 서버가 개별 사용자 세션 상태를 서버 로컬에 저장하지 않고
어디서든 동일하게 요청을 처리할 수 있도록 하는 설계 방식이다.
즉 어떤 서버로 요청이 가더라도 결과가 동일해야 한다.
이를 통해 웹 계층의 수평적 확장(Scaling Out) 이 가능해진다.

## 상태 의존적 아키텍처의 문제점
```
서버 1 ─ 사용자 A 세션 / A 프로필 이미지
서버 2 ─ 사용자 B 세션 / B 프로필 이미지
서버 3 ─ 사용자 C 세션 / C 프로필 이미지
```
특정 사용자의 세션 데이터가 특정 서버에만 저장되어 있다면 로드밸런서가 다른 서버로 요청을 보낼 때 세션이 유지되지 않는다.
이런 구조에서는 Sticky Session(고정 세션)이 필요하지만 서버 장애시 세션 손실 위험이 크고 확장성이 떨어진다.

## 바람직한 해결책: 상태 정보 외부화
세션 저장소 (Redis, Memcached): 사용자 세션, 인증 토큰, 로그인 상태 등 저장
데이터베이스 (MySQL, PostgreSQL): 사용자 정보, 프로필, 영속 데이터 관리

## 무상태 웹 계층의 장점
* 수평 확장이 용이하다
  * 서버 추가시 별도의 세션 복제가 불필요하다
* 장애 복원력 향상
  * 특정 서버 장애에도 서비스 지속이 가능하다
* 배포 용이
  * 서버간 데이터 동기화 부담이 감소한다.
* 로드밸런싱 효율 증가
  * 트래픽을 모든 서버에 균등하게 분산할 수 있다.

## Cache Stale 데이터 문제
1. Writer(MySQL Master) → 데이터를 갱신 (쓰기 연산)
2. Reader(MySQL Slave) → Master의 변경 사항을 비동기로 복제
3. Cache Layer(Redis 등) → Reader에서 읽은 결과를 캐시

위 상황에서 Master → Slave 간 데이터 동기화가 실시간이 아니기 때문에 딜레이가 발생할 수 있다. (복제 지연)
Reader에서 읽은 낡은 데이터를 캐시에 저장하면 Stale한 데이터를 서빙하게 된다.

해결책
* Cache에 저장된 데이터의 유효기간을 설정하여 일정 시간이 지나면 Cache가 자동으로 무효화되도록 한다.
* 캐시를 저장할 때는 반드시 최신 데이터 소스(Master)에서 읽은 값을 기반으로 저장한다.
  * Read 전용 트래픽은 Slave로 가되 개시 생성시에만 Master 이용
* 캐시 갱신을 Writer가 직접 수행
  * Writer가 DB에 쓰기와 동시에 캐시도 직접 갱신