> 참고: 가상 면접 사례로 배우는 대규모 시스템 설계 기초 > 분산 시스템을 위한 유일 ID 생성기 설계

## 1단계 문제 이해 및 설계 범위 확정

요구사항

- ID는 유일해야 한다.
- ID는 숫자로만 구성되어야 한다.
- ID는 64비트로 표현될 수 있는 값이어야 한다.
- ID는 발급 날짜에 따라 정렬 가능해야 한다.
- 초당 10,000개의 ID를 만들 수 있어야 한다.

### 접근법1 - 다중 마스터 복제

<img width="368" height="186" alt="Image" src="https://github.com/user-attachments/assets/a98878ff-69f3-4e8c-8ed6-f90f724c7a34" />

각 데이터베이스는 `auto_increment` 기능을 이용해 id를 생성하지만
다음 id를 계산할 때 1씩 증가시키는 대신 현재 서버 수(K) 만큼 증가시키도록 설정한다.

DB1 → 1, 3, 5, ...
DB2 → 2, 4, 6, ...

장점

* 여러 DB가 동시에 id를 생성할 수 있어 id 생성 처리량(throughput)을 높일 수 있다.

한계

* 여러 데이터 센터에 분산된 환경에서 시작값(offset)과 증가폭(K)을 전역적으로 일관되게 관리하고 배포하기가 어렵다. 규모가 커질수록 운영 난도가 급격히 올라간다.
* id가 시간 순서대로 증가한다고 보장되지 않는다
* 서버 수 변경이 어려워진다.
    * 서버 추가/삭제 시 증가폭(K)이 바뀌면서 ID 생성 규칙 전체가 영향을 받는다.
      예) 서버가 2대 → 3대로 늘어나면 기존에 +2 간격으로 생성되던 id가 갑자기 +3 간격으로 바뀌어 수열이 뒤섞이고 운영 리스크가 생긴다.

### 접근법2 - UUID

UUID는 128비트로 구성된 전역적으로 유일한 식별자다.
각 서버는 서로 조율하지 않고도 독립적으로 UUID를 생성할 수 있다. (동기화 이슈가 없다)

한계

* 시간순 정렬이 불가능하다.
* 문자열 형태이며 숫자가 아닐 수 있다.

### 접근법3 - 티켓서버

`auto_increment` 기능을 갖춘 데이터베이스 서버, 즉 티켓 서버를 중앙 집중형으로 하나만 사용하는 것이다.

장점

* 유일성이 보장되는 오직 숫자로만 구성된 id를 쉽게 만들 수 있다.
* 구현하기 쉽고 중소 규모 애플리케이션에 적합하다.

단점

* 티켓 서버가 단일 장애 지점이 된다.

### 접근법4 - 트위터 스노플레이크 접근법

스노플레이크 id란 64비트 정수 숫자로 이루어진 id 생성 방식이며
트위터가 분산 시스템에서 “충돌 없는 전역 id 생성”을 위해 만든 방식이다.

특징:

* 전역적으로 유일하다 (unique)
* 숫자라서 정렬이 가능하다.
* 시간순으로 증가한다.
* 중앙 서버 없이 각 노드가 독립적으로 생성할 수 있다.

id 구조(64 bit)

<img width="871" height="186" alt="Image" src="https://github.com/user-attachments/assets/128b9ebc-566e-45e7-bd73-9059d146e1b9" />

| Section  | Bit 수 | 설명                       |
|----------|-------|--------------------------|
| 사인 비트    | 1     | 항상 0 (음수 여부 판단용 비트)      |
| 타임스탬프    | 41    | epoch 기준 경과 밀리초(ms)      |
| 데이터센터 id | 5     | 어느 데이터센터에 속하는지 (2^5 32개) |
| 서버 id    | 5     | 데이터센터 내의 서버 번호 (2^5 32개) |
| 일련번호     | 12    | 같은 밀리초에 생성되는 증가 번호       |

* 1밀리초 안에서도 최대 4096개의 id 생성이 가능하다.
* 동시성이 낮고 수명이 긴 애플리케이션이라면 일련번호 섹션의 길이를 줄이고 타임스탬프 섹션의 길이를 늘리는 것이 효과적일 수 있다.

* 타임스탬프
  id가 항상 시간순으로 커지므로 정렬이 가능하다.
  기준 시간(epoch)부터 몇 ms가 지났는지
  41비트로 표현할 수 있는 타임스탬프의 최댓값은 2^41 - 1 = 2199023255551밀리초이다.
  즉 약 69년 동안 사용 가능

예시)
41비트를 십진수로 변환 → 트위터 기원 시각(epoch)을 더함 → 결과로 얻어진 밀리초를 utc 시각으로 변환

* 일련번호
  같은 서버가 같은 밀리초 안에서 여러 id를 생성하는 경우 증가하는 번호 (밀리초가 바뀌면 다시 0 리셋)
  12비트 → 2^12 = 4096개