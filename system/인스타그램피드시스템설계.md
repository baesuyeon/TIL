> 참고: 가상 면접 사례로 배우는 대규모 시스템 설계 기초 > 뉴스 피드 시스템 설계

## 설계 범위 확정
* 게시글을 올릴 수 있어야 하고 친구들이 올린 게시글을 볼 수 있어야 한다.
* 게시글은 시간 역순으로 표시된다.
* 한명의 사용자는 최대 5000명의 친구를 가질 수 있다
* 트래픽 규모는 매일 천만명이 방문한다.
* 게시글에는 이미지나 비디오 등의 미디어 파일이 포함될 수 있다.

## 개략적인 설계안 제시
* 게시글 발행 : 게시글을 올리면 해당 데이터를 캐시, DB에 저장 후 친구의 뉴스피드에도 전송
* 피드 조회 : **모든 친구의 포스팅을 시간 흐름 역순으로 모아 노출**

## 게시글 업로드 API
`[POST] /v1/me/feed`

인자
* 바디(body): 포스팅 내용
* Authorization 헤더 : API 호출 인증

**설계**

* 처리율 제한: 서버는 스팸을 막고 유해한 콘텐츠가 자주 올라오는 것을 방지하기 위해 특정 기간동안 한 사용자가 올릴 수 있는 포스팅의 수에 제한을 둘 수 있다.
* 새 게시글을 데이터베이스와 캐시에 저장한다.
* 새 게시글을 타인의 피드에 전송(**팬아웃**)
  * 새 게시글을 그 사용자와 친구 관계에 있는 모든 사람들에게 전달한다.

## 홈 피드 API
`[GET] /v1/me/feed`
* 캐시에서 홈 피드를 가져온다.
  * 홈 피드를 렌더링할 때 필요한 피드 id를 보관한다.

## 캐시를 적용하지 않는 경우
A 유저가 피드 조회 요청을 하는 경우 DB 부하가 커질 수 있다.
```
friends = getFriends(userId)               // A의 친구가 5000명일 때
posts = []

for (friend in friends) {
    posts += getRecentPosts(friend.id)     // 친구별 최근 글 조회
}

feed = posts.sortedByDescending { createdAt }
```

```text
INDEX (author_id, created_at DESC)

SELECT post_id, author_id, created_at
  FROM posts
  WHERE author_id IN (/* 5000명 */)
  ORDER BY created_at DESC
  LIMIT 50;
```
쿼리 5000번 대신 IN 한방 쿼리를 수행할 수 있지만

따라서 무엇을 캐시에 저장할 것인가, 언제 미리 계산해 둘 것인가를 고민해야 한다.

```
feed:user:1001 = [postId=33, postId=27, postId=19 ...]
```
게시글 본문이 아닌 시간순으로 정렬된 postId 리스트를 캐시하고 실제 화면에 필요한 정보는 나중에 조립할 수 있다.
1. feed cache 1번 조회
2. postId 20~50개에 대해서
3. post 캐시 / 유저 캐시 조회

## 포스트 전송(팬아웃 서비스) - 어떤 이벤트(게시글 작성)를 여러 대상(친구들의 feed cache)에 전파하는 것
**팬아웃에는 두 가지 방식이 있다.**

(1) 쓰기 시점에 팬아웃

A가 글을 쓰는 순간 B~E의 feed cache에 postId를 바로 넣는다.
B가 피드를 처음 열때 조회가 엄청 빠르지만, B가 3달동안 앱을 켜지 않아도 B의 feed cache가 계속 갱신된다. 

* 새로운 게시글이 작성되는 시점에 친구들 홈 피드 캐시에 해당 포스팅을 기록한다.
* (+) 새 게시글이 기록되는 순간에 피드가 갱신되므로 뉴스 피드를 읽는데 드는 시간이 짧아지지만
* (-) 친구가 많은 경우 친구 목록을 가져오고 그 친구들의 피드를 갱신하는데 많은 시간이 소요될 수 있다.
* (-) 서비스를 자주 이용하지 않는 사용자의 피드까지 갱신해야 하므로 컴퓨팅 자원이 낭비된다.

(2) 읽기 시점에 팬아웃

A의 Post DB와 Post Cache에만 저장하고 친구들의 feed cache는 건드리지 않는다.
B가 피드를 열 때 feed cache 를 생성한다.

* 피드를 읽어햐 하는 시점에 피드를 갱신한다.
* (+) 비활성 사용자의 경우 이 모델이 유리하다
* (-) 홈 피드를 읽는데 많은 시간이 소요될 수 있다.

```text
feed:user:1001 =
  { 
    [postId=33, postId=27, postId=19 ...], 
    lastSeenPostId = 33
  }
```

* 두 번째 피드 조회 시 동작 (2페이지가 아님)
그 이후에 생긴 글만 따로 조회
```text
SELECT post_id
FROM posts
WHERE author_id IN (friends)
  AND post_id > lastSeenPostId
ORDER BY post_id DESC
LIMIT 50;
```

```text
finalFeed = merge(
    newPosts,      // [93, 92, 91]
    cachedFeed     // [90, 88, 85, ...]
  )
```

## 커서 기반 페이징
feed cache는 여러 페이지 분량의 postId 리스트를 갖고 있다.
```text
feed:user:1001에서
postId < 101 인것 중
20개 가져오기
```
feed cache 먼저 보고 feed cache에 충분한 데이터가 없을 때 DB를 본다.

```text
SELECT post_id
FROM posts
WHERE author_id IN (friends)
  AND post_id < cursorPostId
ORDER BY post_id DESC
LIMIT (20 - 4);
```

```text
finalFeed = merge(
    feedCachePage, // [93, 92, 91]
    postsAfterCursor     // [90, 88, 85, ...]
  )
```

참고)
시간(created_at)은 페이징 커서로는 불안정하기 때문에 (같은 시간에 여러 게시글이 생성될 수 있기 때문에 중복/누락이 발생할 수 있다)
정렬 기준으로 안정적인 postId를 커서로 많이 사용한다.