WebFlux는 리액티브 웹 프레임워크이고
코루틴은 비동기 코드를 쉽게 쓰기 위한 언어 기능이다. (비동기 코드 표현 방식)
WebFlux 위에서 코루틴을 사용할 수 있어 동일한 논블로킹 모델을 더 읽기 쉬운 코드로 작성할 수 있다.

### Spring Webflux
```kotlin
@GetMapping("/users/{id}")
fun getUser(): Mono<User> =
    userService.findById(id)
```
* 비동기/논블로킹 웹 프레임 워크
* 이벤트 루프 + 리액티브 스트림 기반
* 기본 타입: Mono, Flux
* 목적: 적은 스레드로 많은 요청 처리

### Kotlin Coroutines
suspend 함수로 구성된 비동기 실행 흐름, 실행 단위이다.
상태 머신(FSM)으로 동작한다.

```kotlin
@GetMapping("/users/{id}")
suspend fun getUser(): User =
    userService.findById(id)
```
* 비동기 코드를 동기처럼 쓰게 해주는 언어 기능
* suspend, await
* 목적: 코드 가독성, 유지보수성

Spring WebFlux는 suspend fun을 내부에서 Mono로 변환해서 처리한다.

## 코루틴 빌더와 suspend 함수의 역할
* 코루틴 빌더: 코루틴을 **시작** 시키는 함수
* suspend 함수: 코루틴 안에서 **중단될 수 있는 함수**

코루틴 빌더가 코루틴을 생성하고 실행을 시작하며
suspend 함수는 그 실행흐름 안에서 멈췄다가 다시 이어질 수 있는 지점을 제공한다

## 코루틴 빌더의 종류
새 코루틴을 만든다는것은 내부적으로 아래 항목들이 일어난다는 뜻이다.
* 새로운 Continuation
* 새로운 상태 머신(FSM)
* 새로운 Job
* 부모–자식 관계 등록

→ launch, async, runBlocking이 새 코루틴을 만든다.

| 함수               | 새 코루틴 | 새 Job   | 역할         |
| ---------------- | ----- | ------- | ---------- |
| `launch`         | ✅     | ✅       | 실행 시작      |
| `async`          | ✅     | ✅       | 실행 + 결과    |
| `withContext`    | ❌     | ❌       | context 전환 |
| `coroutineScope` | ❌     | ⚠️ (부모) | 구조 생성      |

### runBlocking { }
```kotlin
expect fun <T> runBlocking(
	context: CoroutineContext = EmptyCoroutineContext, 
	block: suspend CoroutineScope.() -> T
): T
```
* 현재 스레드를 블로킹
* runBlocking 내부에서 생성된 코루틴과 모든 자식 코루틴이 완료될 때까지 대기
* 사용이 권장되지 않으며 일반 함수에서 suspend 함수를 호출하기 위해 존재한다.
* 생성하는 것
  * 새로운 코루틴
  * 새로운 Job

### launch { }
```kotlin
fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext, //  동일 루틴에서 Context를 변경할 수 있다
    start: CoroutineStart = CoroutineStart.DEFAULT, 
    block: suspend CoroutineScope.() -> Unit
): Job
```
launch는 독립된 실행 흐름을 만든다.
* 생성하는 것
  * 새로운 코루틴
  * 새로운 Job, 코루틴의 생명주기를 관리하는 Job을 즉시 반환하며 Job으로 코루틴 제어 가능
  * 예: job.cancel(), job.join()
* 반환값
  * Job

### async { }
* 생성하는 것
  * 새로운 코루틴
  * 새로운 Job, 코루틴의 생명주기를 관리하는 Job을 즉시 반환하며 Job으로 코루틴 제어 가능
* ❗️여러 API를 동시에 호출하여 소요시간을 최소화할 수 있다.
* 반환값
  * Deferred<T> → Job + 결과
  * await() 시점에 결과를 기다리며 suspend

## 구조 제어용 suspend 함수
### withContext
```kotlin
withContext(Dispatchers.IO) {
    doSomething()
}
println("doSomething() 이후에 실행")
```
* 새로운 코루틴을 만들지 않는다.
* 새로운 Job을 만들지 않는다.
* 현재 코루틴을 중단(suspend) 시켰다가 재개한다.
* 하는 일
  * 기존 Job을 유지한다.
    * 부모가 취소되면 즉시 같이 취소된다.
  * CoroutineContext만 변경한다.

suspension point로 동작한다.
이 코드에서 아래 과정이 일어난다.
1. 현재 코루틴이 suspend
2. 실행에 필요한 상태(FSM 상태) 저장
3. Dispatcher만 바꿔서
4. 같은 코루틴을 resume (코루틴 identity는 동일)

### coroutineScope
```kotlin
coroutineScope {
    launch { workA() }
    launch { workB() }
}
```
* 새로운 코루틴을 만들지 않는다.
* 생성하는 것
  * 새로운 Scope
    * 자식 코루틴을 위한 구조를 만든다. (자식 코루틴을 생성하는 것은 아님)
    * 자식 코루틴을 묶는 Job 컨테이너(Scope), 자식들을 관리하는 울타리 생성
    * 내부 자식들이 끝날 때까지 대기한다.
  * 내부 자식(launch/async)들이 가질 부모 Job

## 코루틴의 중단과 재개
코루틴은 언제든 중단(suspend)되었다가 재개(resume)될 수 있다.
이때
* 재개 시 같은 스레드가 아닐 수도 있다.
  * 코루틴의 앞부분은 1번 스레드에서 실행되고 뒷부분은 2번 스레드에서 실행될 수 있다
* 즉 코루틴은 스레드에 종속되지 않으며 스레드는 단순히 코루틴을 실행해주는 실행기 역할을 한다

## suspend
코루틴은 기본적으로 일반 함수처럼 순차적으로 실행된다.
launch나 async를 사용하면 실행 흐름을 분리하여 여러 작업을 동시에 진행하도록 구성할 수 있다.
(동시에라고 해도 항상 병렬 실행은 아니다. 같은 Dispatcher 를 사용하는 경우 작업들이 동일한 스레드에서 번갈아 실행될 수 있다.)

```kotlin
suspend fun foo() {
    doA()
    doB()
}
```
```kotlin
withContext(Dispatchers.IO) {
    doA()
}
doB()
```
위 코드들 모두 순차적으로 수행된다.
suspend는 중단될 수 있다는 의미이지 자동으로 동시에 실행된다는 의미가 아니다.

launch/async
```kotlin
launch {
    doA()
}
launch {
    doB()
}
```
```kotlin
val a = async { doA() }
val b = async { doB() }

a.await()
b.await()
```

## suspend 함수와 컴파일러 동작
코틀린 컴파일러는 suspend가 붙은 함수에 추가적인 코드를 추가한다.
컴파일러는 다음과 같은 작업을 수행한다.

* 대상 함수에 Continuation 파라미터를 추가
* Continuation 구현체를 생성
* 함수 내부의 모든 suspend 지점에 동일한 Continuation 객체를 전달
* 코드를 분리해 state machine(FSM) 형태로 변환
  * switch / label 구조로 상태를 관리

코루틴은 내부적으로 FSM(Finite State Machine)기반으로 동작한다.
* 실행 중 suspend 지점에 도달하면 현재 상태 state(label, 로컬 변수)를 Continuation 객체에 저장하고 중단
* 재개 시 저장된 state를 기준으로 다시 실행
* 모든 상태를 처리하면 최종 결과를 caller에게 반환
상태가 전이되며 반복 실행되는 구조이다.

## Job
= 라이프사이클

Job을 하나 응답받으면 코루틴을 하나 만든 것이다.
Job으로 코루틴을 제어할 수 있다는 의미는 우리가 만들어놓은 코루틴을 시작시키거나 취소시키거나 종료할 때까지 우리가 기다릴 수 있다는 의미이다. (join()/cancel())

```kotlin
val job = launch { // launch a new coroutine and keep a reference to its Job
    delay(1000L) // suspend
    println("World!")
}
println("Hello") // launch는 새 코루틴을 생성 후 즉시 Job을 반환하여 기다리지 않아 다음줄이 바로 실행된다.
job.join() // suspend(wait until child coroutine completes, Job은 코루틴의 시작, 완료, 취소 상태 표현하는 객체로 코루틴의 완료를 명시적으로 기다리기 위해 사용할 수 있다)
println("Done")
```
```kotlin
Hello
World!
Done
```
`launch`는 새로운 코루틴을 생성해 실행을 예약하고 즉시 반환한다. (자식 코루틴은 부모와는 분리된 실행 흐름을 가지지만 실제 실행 스레드는 동일할 수도 있고 Dispatcher에 따라 달라진다)
따라서 현재 코루틴은 중단되지 않고 다음 코드(println("Hello"))를 바로 실행한다.
job.join()이 호출되면 현재 코루틴은 자식 코루틴이 완료될 때까지 suspend 되며
자식 코루틴이 종료된 후에 다시 재개되어 "Done"을 출력한다.
이 과정에서 코루틴은 논리적으로 분리된 실행 흐름을 가지지만 실제 실행 스레드는 동일할 수도 있고 Dispatcher에 따라 달라질 수 있다.

## Structured Concurrency
Structured Concurrency는 코루틴의 생명주기를 코드의 스코프 안에 묶어
외부 scope는 내부 모든 코루틴들이 끝날 때 까지 끝날 수 없다.
취소와 예외가 유실되지 않고 부모로 전파되도록 보장하는 실행 모델이다.
부모가 취소되면 자식 코루틴도 자동으로 취소되고
자식 중 하나라도 실패하면 부모로 예외가 전파된다.

## 코루틴 예외 처리
코루틴에서는 자식 코루틴에서 발생한 예외가 부모 코루틴으로 전파된다.
(발생한 예외가 CancellationException인 경우 취소로 간주하고 부모 코루틴에게 전파하지 않는다)
부모 코루틴이 예외를 받으면 부모는 취소되고
그 결과 부모 아래에 있던 다른 모든 자식 코루틴들도 함께 취소된다.
부모 코루틴은 자신의 생명주기 안에서 생성된 모든 자식 코루틴의 성공/실패에 책임을 진다.

자식 코루틴의 실패가 부모나 형제 코루틴에게 영향을 주지 않게 하고 싶을 때 SupervisorJob을 사용한다.

```kotlin
supervisorScope {
  launch {
    throw IllegalArgumentException("fail")
  }

  // b는 영향을 받지 않고 정상 실행됨
  val b = async {
    doSomethingElse()
    "success"
  }
  
  val resultB = b.await()
}
```
자식 코루틴에서 예외가 발생해도 부모 코루틴은 취소되지 않으며 다른 자식 코루틴들도 계속 실행된다.

```kotlin
coroutineScope {
    val a = async {
        runCatching {
            riskyOperation()
        }.getOrNull()   // 실패 시 null로 흡수
    }

    val b = async {
      runCatching {
        riskyOperation()
      }.getOrNull()   // 실패 시 null로 흡수
    }

    val resultA = a.await()   // 예외 발생하지 않음
    val resultB = b.await()
}
```
위 코드에서 async 내부에서 예외를 모두 흡수하고 있어 부모 스코프로 전파될 실패가 존재하지 않기 때문에
coroutineScope는 필수가 아니다.

코루틴이 취소에 협조하는 방법
* suspend 함수를 호출한다.
* isActive 로 직접 상태를 확인해 cancellationException 을 던진다.

```kotlin
fun main(): Unit = runBlocking {
    val job1 = launch {
        delay(1_000L)
        printWithThread("Job 1")
    }

    val job2 = launch {
        delay(1_000L)
        printWithThread("Job 2")
    }

    delay(100) // 첫 번째 코루틴 코드가 시작되는 것을 잠시 기다린다
    job1.cancel()
}

fun printWithThread(str: Any) {
    println("[${Thread.currentThread().name}] $str")
}
```
```text
[main @coroutine#3] Job 2
```
suspend 함수를 사용하면 취소에 협조할 수 있다.
첫번째 코루틴은 취소에 잘 협조하고 있기에 정상적으로 취소되어 Job 1이 출력되지 않고 Job 2만 출력되었다.
(자식 코루틴에서 발생한 예외가 아닌 취소는 부모 코루틴으로 전파되지 않는다)

`job.cancel()`은 즉시 예외를 던지지 않고 취소 상태만 표시하며
코루틴이 delay와 같은 취소 가능한 suspend 지점에 도달했을 때
`CancellationException`이 발생하면서 코루틴이 종료된다.

```kotlin
fun main(): Unit = runBlocking {
    val job = launch {
        var i = 1
        var nextPrintTime = System.currentTimeMillis()
        while(i <= 5) {
            if (nextPrintTime <= System.currentTimeMillis()) {
                printWithThread("${i++}번째 출력")
                nextPrintTime += 1_000L
            }
        }
    }

    delay(100) // 위 코루틴 코드가 시작되는 것을 잠시 기다린다
    job.cancel()
}

fun printWithThread(str: Any) {
    println("[${Thread.currentThread().name}] $str")
}
```
```text
[main @coroutine#2] 1번째 출력
[main @coroutine#2] 2번째 출력
[main @coroutine#2] 3번째 출력
[main @coroutine#2] 4번째 출력
[main @coroutine#2] 5번째 출력
```
취소 요청이 들어오면 Job은 isCancelled = true가 되지만
suspend 지점이 없어 취소를 감지할 기회가 없었다.

```kotlin
fun main(): Unit = runBlocking {
    val job = launch {
        var i = 1
        var nextPrintTime = System.currentTimeMillis()
        while(i <= 5) {
            if (nextPrintTime <= System.currentTimeMillis()) {
                printWithThread("${i++}번째 출력")
                nextPrintTime += 1_000L
            }

			if (!isActive) { // 코루틴 스스로 취소를 확인한다
		        throw CancellationException()
		    }
        }
    }

    delay(100) // 위 코루틴 코드가 시작되는 것을 잠시 기다린다
    job.cancel()
}

fun printWithThread(str: Any) {
    println("[${Thread.currentThread().name}] $str")
}
```
위 코드에서 launch는 즉시 반환되지만 자식 코루틴이 같은 스레드에서 suspend 지점 없이 실행되면 부모 코루틴은 실행 기회를 얻지 못할 수 있다.
자식 코루틴에 suspend 지점이 없어 runBlocking, launch이 같은 스레드에서 실행

즉시 반환과 즉시 스레드 양보는 다르다

| 개념             | 의미                                 |
| -------------- | ---------------------------------- |
| `launch` 즉시 반환 | Job 객체를 바로 돌려줌                     |
| 실행 양보          | 스레드를 다른 코루틴에게 넘김 (suspend / yield) |

```kotlin
fun main(): Unit = runBlocking {
    val job = launch(Dispatchers.Default) {
        var i = 1
        var nextPrintTime = System.currentTimeMillis()
        while(i <= 5) {
            if (nextPrintTime <= System.currentTimeMillis()) {
                printWithThread("${i++}번째 출력")
                nextPrintTime += 1_000L
            }

            if (!isActive) { // 코루틴 스스로 취소를 확인한다
                println("들어옴?")
                throw CancellationException()
            }
        }
    }

    delay(100) // 위 코루틴 코드가 시작되는 것을 잠시 기다린다
    printWithThread("취소 시작")
    job.cancel()
}

fun printWithThread(str: Any) {
    println("[${Thread.currentThread().name}] $str")
}
```
```text
[DefaultDispatcher-worker-1 @coroutine#2] 1번째 출력
[main @coroutine#1] 취소 시작
들어옴?
```
launch에 의해 만든 코루틴은 다른 스레드에서 동작한다.
코루틴을 만들 때 사용한 함수 블록 안에서는 `isActive` 라는 프로퍼티에 접근할 수 있어
현재 코루틴이 활성화 되어 있는지, 아니면 취소 신호를 받았는지 구분할 수 있게 해준다.
`isActive` 로 직접 상태를 확인해 `cancellationException` 을 던져 취소에 협조할 수 있다.

### 코루틴 스코프
CoroutineScope는 코루틴이 생성될 수 있는 영역을 의미하며 내부적으로 CoroutineContext를 보유한다. (CoroutineContext에는 Job, Dispatcher 등 정보가 들어있다)
모든 코루틴은 각자의 스코프(생명 주기)를 갖는다.

부모 코루틴이 가진 CoroutineScope를 통해 자식 코루틴이 생성되면
자식 코루틴은 부모의 CoroutineContext를 상속받는다. (withContext(...)로 일부 요소는 교체할 수 있다)
코루틴이 같은 스코프에 있다는 것은 같은 **부모 Job을 공유하고 취소/실패가 서로 전파될 수 있다는 것**을 의미한다.

`CoroutineScope(Dispatchers.Default)`
* 새로운 root 스코프를 만들고 싶을 때 사용할 수 있다.
* 이 스코프에서 launch/async로 생성된 코루틴은 부모 Job이 없는 root Job을 갖게 된다.

`coroutineScope {}`
* 새로운 Job 경계를 하나 만들고 요청 Job의 자식으로 붙음
* 이 블록은 새로운 CoroutineScope를 생성하고 블록 안에서 시작된 모든 코루틴의 완료를 직접 책임진다.
* 내부의 모든 자식 코루틴이 완료될 때까지 suspend 된다

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking { // this: CoroutineScope(GlobalScope)

    launch { // runBlocking CoroutineScope 상속
        delay(200L)
        println("Task from runBlocking")
    }

    coroutineScope { // 새로운 Scope가 만들어진다
        launch { // 바로 위 Scope로부터 상속
            delay(100L)
            println("Task from nested launch")
        }
        delay(400L)
        println("Task from coroutineScope")
    }

    // 새로운 Scope에서 빠져나와야만 실행 가능하다.
    println("end of runBlocking") // runBlocking CoroutineScope 상속
}
```
```kotlin
Task from nested launch
Task from runBlocking
Task from coroutineScope
end of runBlocking
```
어떤 스코프에서 진행하다가 하위 스코프를 만나면, 해당 하위 스코프가 완전히 끝나야 그 다음 라인 실행이 가능하다.
coroutineScope는 하위 작업이 끝난 뒤에야만 완료된다.
마지막 출력은 coroutineScope 의 모든 하위 작업이 끝나야만 실행될 수 있다.

```kotlin
coroutineScope {
  launch { workA() }
  launch { workB() }
}

coroutineScope Job
ㄴ launch Job A
ㄴ launch Job B
```
* A 실패 → 부모 Job 실패 → B 취소
* 부모 취소 → A, B 모두 취소

```kotlin
coroutineScope {
    launch(Dispatchers.IO) { workA() } // Dispatcher가 달라 스레드는 다르지만 스코프가 같다.
    launch(Dispatchers.Default) { workB() }
}
```
같은 스코프 != 같은 스레드
* A 실패 → 부모 Job 실패 → B 취소
* 부모 취소 → A, B 모두 취소

```kotlin
CoroutineScope(Dispatchers.IO).launch { workA() }
CoroutineScope(Dispatchers.IO).launch { workB() }
// 즉시 다음 줄 실행됨

Root Job A
ㄴ workA

Root Job B
ㄴ workB
```
다른 스코프는 서로 아무 관계가 없어 하나가 실패해도 다른 쪽에 영향이 없다.

```kotlin
supervisorScope {
    launch { workA() }
    launch { workB() }
}
// 여기로 오기 전에 workA, workB는 반드시 종료
```
같은 스코프지만 실패를 서로에게 전파하지 않는다. (같은 책임 아래에서 실패만 격리)

## Dispatcher
디스패처는 해당 코루틴이 실행에 사용할 스레드를 결정한다.

```kotlin
launch {
}

launch (Dispatchers.Default) {
}

launch (Dispatchers.IO) {
    
}
```
launch, async와 같은 코루틴 빌더는 선택적으로 CoroutineContext 매개변수를 사용하여 새 코루틴에 대한 디스패처를 명시적으로 지정할 수 있다.
매개변수 없이 사용될 경우 해당 코루틴이 실행되는 코루틴 스코프의 컨텍스트를 상속받는다.

기본 Dispatcher 종류
* Dispatchers.Default
  * CPU-bound 작업
  * CPU 코어 수를 기준으로한 고정에 가까운 스레드 풀
* Dispatchers.IO
  * Blocking I/O 전용
  * 파일, DB, 네트워크 작업
Webflux에서는 재개 시에도 Reactor Scheduler가 관리하는 스레드에서 실행 
WebFlux에서 Dispatcher를 직접 써야 하는 경우는 딱 하나 Blocking 코드가 있을 때만이다.
```kotlin
suspend fun api(): Result =
  withContext(Dispatchers.IO) {
      blockingJdbcCall()
  }
```
기존 Job을 유지한 채 CoroutineContext의 일부(Dispatcher)만 교체한다

만약 응답을 먼저 내려주고 백그라운드에서 작업을 수행하고 싶은 경우가 있다면
코루틴을 부모 요청의 생명주기 밖에서 실행해야한다.
이때 `coroutineScope { launch {...} }`를 사용하게 되면 
해당 블록은 내부에서 시작된 모든 코루틴이 완료될 때까지 반환되지 않기 때문에 caller는 비동기 작업이 끝날 때까지 대기하게 된다.

```kotlin
CoroutineScope(Dispatchers.IO).launch {
    delay(3000)
}
```
새로운 CoroutineScope를 생성하고
그 Scope 안에 새로운 Job을 생성한다.
이 Job은 어떤 부모 Job에도 속하지 않아 루트 Job이 된다.

`coroutineScope { launch {...} }`를 사용하게 되면 caller가 비동기 작업이 모두 수행될 때까지 대기하게된다.

| 구분         | coroutineScope { }               | CoroutineScope().launch |
|------------|----------------------------------| ----------------------- |
| 새 Scope 생성 | ⭕                                | ⭕                       |
| 새 Job 생성   | ⭕                                | ⭕                       |
| 부모 Job 연결  | ⭕ (부모 Job에 연결된 자식 Job을 하나 더 만든다) | ❌                       |
| 루트 Job     | ❌                                | ⭕                       |
| 호출자 대기     | ⭕                                | ❌                       |
| 백그라운드 실행   | ❌                                | ⭕                       |

```kotlin
suspend fun api(): Result = coroutineScope {
  val a = async { callApiA() }
  val b = async { callApiB() }

  combine(a.await(), b.await())
}
```
현재 요청 스코프에서 async로 동시성만 생성 (Dispatcher는 상위 컨텍스트에 맡김)
비동기/non-blocking API 호출에 최적

```kotlin
suspend fun api(): Result = coroutineScope {
    val a = async {
        withContext(Dispatchers.IO) { blockingApiA() }
    }
    val b = async {
        withContext(Dispatchers.IO) { blockingApiB() }
    }

    combine(a.await(), b.await())
}
```
전체 구조는 동일하지만 blocking 구간만 IO Dispatcher로 격리