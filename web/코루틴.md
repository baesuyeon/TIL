WebFlux는 리액티브 웹 프레임워크이고
코루틴은 비동기 코드를 쉽게 쓰기 위한 언어 기능이다. (비동기 코드 표현 방식)
WebFlux 위에서 코루틴을 사용할 수 있어 동일한 논블로킹 보델을 더 읽기 쉬운 코드로 작성할 수 있다.

* Spring Webflux
  * 비동기/논블로킹 웹 프레임 워크
  * 이벤트 루프 + 리액티브 스트림 기반
  * 기본 타입: Mono, Flux
  * 목적: 적은 스레드로 많은 요청 처리
```kotlin
@GetMapping("/users/{id}")
fun getUser(): Mono<User> =
    userService.findById(id)
```

* Kotlin Coroutines
  * 비동기 코드를 동기처럼 쓰게 해주는 언어 기능
  * suspend, await
  * 목적: 코드 가독성, 유지보수성
```kotlin
@GetMapping("/users/{id}")
suspend fun getUser(): User =
    userService.findById(id)
```
Spring WebFlux는 suspend fun을 내부에서 Mono로 변환해서 처리한다.

## 코루틴 빌더와 suspend 함수의 역할
코루틴 빌더: 코루틴을 **시작**하는 진입점
suspend 함수: 코루틴 안에서 **중단될 수 있는 함수**

코루틴 빌더가 코루틴을 생성하고 실행을 시작하며
suspend 함수는 그 실행흐름 안에서 멈췄다가 다시 이어질 수 있는 지점을 제공한다

## 코루틴 빌더의 종류
* runBlocking { } 
  * 현재 스레드를 블로킹
  * runBlocking 내부에서 생성된 코루틴과 모든 자식 코루틴이 완료될 때까지 대기

* launch { }
  * 반환값 없음
  * 코루틴의 생명주기를 관리하는 Job을 반환하여 코루틴 제어 가능
  * 예: job.cancel(), job.join()

* async { }
  * 결과 값을 반환(Deferred<T>)
  * await() 시점에 결과를 기다리며 suspend
  * ❗️여러 API를 동시에 호출하여 소요시간을 최소화할 수 있다.

## 코루틴의 중단과 재개
코루틴은 언제든 중단(suspend)되었다가 재개(resume)될 수 있다.
이때
* 재개 시 같은 스레드가 아닐 수도 있다.
  * 코루틴의 앞부분은 1번 스레드에서 실행되고 뒷부분은 2번 스레드에서 실행될 수 있다
* 즉 코루틴은 스레드에 종속되지 않으며 스레드는 단순히 코루틴을 실행해주는 실행기 역할을 한다

## suspend 함수와 컴파일러 동작
코틀린 컴파일러는 suspend가 붙은 함수에 추가적인 코드를 추가한다.
컴파일러는 다음과 같은 작업을 수행한다.

* 대상 함수에 Continuation 파라미터를 추가
* Continuation 구현체를 생성
* 함수 내부의 모든 suspend 지점에 동일한 Continuation 객체를 전달
* 코드를 분리해 state machine(FSM) 형태로 변환
  * switch / label 구조로 상태를 관리

코루틴은 내부적으로 FSM(Finite State Machine)기반으로 동작한다.
* 실행 중 suspend 지점에 도달하면 현재 상태 state(label, 로컬 변수)를 Continuation 객체에 저장하고 중단
* 재개 시 저장된 state를 기준으로 다시 실행
* 모든 상태를 처리하면 최종 결과를 caller에게 반환
상태가 전이되며 반복 실행되는 구조이다.

## 코루틴 예외 처리
코루틴에서는 자식 코루틴에서 발생한 예외가 부모 코루틴으로 전파된다.
부모 코루틴이 예외를 받으면 부모는 취소되고
그 결과 부모 아래에 있던 다른 모든 자식 코루틴들도 함께 취소된다.
부모 코루틴은 자신의 생명주기 안에서 생성된 모든 자식 코루틴의 성공/실패에 책임을 진다.

자식 코루틴의 실패가 부모나 형제 코루틴에게 영향을 주지 않게 하고 싶을 때 SupervisorJob을 사용한다.
```kotlin
supervisorScope {
  launch {
    throw IllegalArgumentException("fail")
  }

  b는 영향을 받지 않고 정상 실행됨
  val b = async {
    doSomethingElse()
    "success"
  }
  
  val resultB = b.await()
}
```
자식 코루틴에서 예외가 발생해도 부모 코루틴은 취소되지 않으며 다른 자식 코루틴들도 계속 실행된다.

```kotlin
coroutineScope {
    val a = async {
        runCatching {
            riskyOperation()
        }.getOrNull()   // 실패 시 null로 흡수
    }

    val b = async {
      runCatching {
        riskyOperation()
      }.getOrNull()   // 실패 시 null로 흡수
    }

    val resultA = a.await()   // 예외 발생하지 않음
    val resultB = b.await()
}
```
위 코드에서 async 내부에서 예외를 모두 흡수하고 있어 부모 스코프로 전파될 실패가 존재하지 않기 때문에
coroutineScope는 필수가 아니다.

### 코루틴 스코프
CoroutineScope는 코루틴이 생성될 수 있는 영역을 의미하며 내부적으로 CoroutineContext를 보유한다. (CoroutineContext에는 Job, Dispatcher 등 정보가 들어있다)
코루틴이 존재한다는 것은 항상 어딘가에 CoroutineScope가 존재한다는 것을 의미한다.

부모 코루틴이 가진 CoroutineScope를 통해 자식 코루틴이 생성되면
자식 코루틴은 부모의 CoroutineContext를 상속받는다. (withContext(...)로 일부 요소는 교체할 수 있다)
코루틴이 같은 스코프에 있다는 것은 같은 부모 Job을 공유하고 취소/실패가 서로 전파될 수 있다는 것을 의미한다.

`coroutineScope {}`
* 새로운 Job 경계를 하나 만들고 요청 Job의 자식으로 붙음
* 이 블록은 새로운 CoroutineScope를 생성하고 블록 안에서 시작된 모든 코루틴의 완료를 직접 책임진다.
* 내부의 모든 자식 코루틴이 완료될 때까지 suspend 된다

```kotlin
coroutineScope {
  launch { workA() }
  launch { workB() }
}

coroutineScope Job
├─ launch Job A
└─ launch Job B
```
* A 실패 → 부모 Job 실패 → B 취소
* 부모 취소 → A, B 모두 취소

```kotlin
coroutineScope {
    launch(Dispatchers.IO) { workA() } // Dispatcher가 달라 스레드는 다르지만 스코프가 같다.
    launch(Dispatchers.Default) { workB() }
}
```
같은 스코프 != 같은 스레드
* A 실패 → 부모 Job 실패 → B 취소
* 부모 취소 → A, B 모두 취소

```kotlin
CoroutineScope(Dispatchers.IO).launch { workA() }
CoroutineScope(Dispatchers.IO).launch { workB() }
// 즉시 다음 줄 실행됨

Root Job A
└─ workA

Root Job B
└─ workB
```
다른 스코프는 서로 아무 관계가 없어 하나가 실패해도 다른 쪽에 영향이 없다.

```kotlin
supervisorScope {
    launch { workA() }
    launch { workB() }
}
// 여기로 오기 전에 workA, workB는 반드시 종료
```
같은 스코프지만 실패를 서로에게 전파하지 않는다. (같은 책임 아래에서 실패만 격리)

## 기본 Dispatcher 종류
* Dispatchers.Default
  * CPU-bound 작업
  * CPU 코어 수를 기준으로한 고정에 가까운 스레드 풀
* Dispatchers.IO
  * Blocking I/O 전용
  * 파일, DB, 네트워크 작업
Webflux에서는 재개 시에도 Reactor Scheduler가 관리하는 스레드에서 실행 
WebFlux에서 Dispatcher를 직접 써야 하는 경우는 딱 하나 Blocking 코드가 있을 때만이다.
```kotlin
suspend fun api(): Result =
  withContext(Dispatchers.IO) {
      blockingJdbcCall()
  }
```
기존 Job을 유지한 채 CoroutineContext의 일부(Dispatcher)만 교체한다

만약 응답을 먼저 내려주고 백그라운드에서 작업을 수행하고 싶은 경우가 있다면
코루틴을 부모 요청의 생명주기 밖에서 실행해야한다.
이때 `coroutineScope { launch {...} }`를 사용하게 되면 
해당 블록은 내부에서 시작된 모든 코루틴이 완료될 때까지 반환되지 않기 때문에 caller는 비동기 작업이 끝날 때까지 대기하게 된다.

```kotlin
CoroutineScope(Dispatchers.IO).launch {
    delay(3000)
}
```
새로운 CoroutineScope를 생성하고
그 Scope 안에 새로운 Job을 생성한다.
이 Job은 어떤 부모 Job에도 속하지 않아 루트 Job이 된다.

`coroutineScope { launch {...} }`를 사용하게 되면 caller가 비동기 작업이 모두 수행될 때까지 대기하게된다.

| 구분         | coroutineScope { }               | CoroutineScope().launch |
|------------|----------------------------------| ----------------------- |
| 새 Scope 생성 | ⭕                                | ⭕                       |
| 새 Job 생성   | ⭕                                | ⭕                       |
| 부모 Job 연결  | ⭕ (부모 Job에 연결된 자식 Job을 하나 더 만든다) | ❌                       |
| 루트 Job     | ❌                                | ⭕                       |
| 호출자 대기     | ⭕                                | ❌                       |
| 백그라운드 실행   | ❌                                | ⭕                       |

```kotlin
suspend fun api(): Result = coroutineScope {
  val a = async { callApiA() }
  val b = async { callApiB() }

  combine(a.await(), b.await())
}
```
현재 요청 스코프에서 async로 동시성만 생성 (Dispatcher는 상위 컨텍스트에 맡김)
비동기/non-blocking API 호출에 최적

```kotlin
suspend fun api(): Result = coroutineScope {
    val a = async {
        withContext(Dispatchers.IO) { blockingApiA() }
    }
    val b = async {
        withContext(Dispatchers.IO) { blockingApiB() }
    }

    combine(a.await(), b.await())
}
```
전체 구조는 동일하지만 blocking 구간만 IO Dispatcher로 격리