WebFlux는 리액티브 웹 프레임워크이고
코루틴은 비동기 코드를 쉽게 쓰기 위한 언어 기능이다. (비동기 코드 표현 방식)
WebFlux 위에서 코루틴을 사용할 수 있어 동일한 논블로킹 보델을 더 읽기 쉬운 코드로 작성할 수 있다.

* Spring Webflux
  * 비동기/논블로킹 웹 프레임 워크
  * 이벤트 루프 + 리액티브 스트림 기반
  * 기본 타입: Mono, Flux
  * 목적: 적은 스레드로 많은 요청 처리
```kotlin
@GetMapping("/users/{id}")
fun getUser(): Mono<User> =
    userService.findById(id)
```

* Kotlin Coroutines
  * 비동기 코드를 동기처럼 쓰게 해주는 언어 기능
  * suspend, await
  * 목적: 코드 가독성, 유지보수성
```kotlin
@GetMapping("/users/{id}")
suspend fun getUser(): User =
    userService.findById(id)
```
Spring WebFlux는 suspend fun을 내부에서 Mono로 변환해서 처리한다.

## 코루틴 빌더와 suspend 함수의 역할
코루틴 빌더: 코루틴을 **시작**하는 진입점
suspend 함수: 코루틴 안에서 **중단될 수 있는 함수**

코루틴 빌더가 코루틴을 생성하고 실행을 시작하며
suspend 함수는 그 실행흐름 안에서 멈췄다가 다시 이어질 수 있는 지점을 제공한다

## 코루틴 빌더의 종류
* runBlocking { } 
  * 현재 스레드를 블로킹
  * runBlocking 내부에서 생성된 코루틴과 모든 자식 코루틴이 완료될 때까지 대기

* launch { }
  * 반환값 없음
  * Job을 반환하여 코루틴 제어 가능
  * 예: job.cancel(), job.join()

* async { }
  * 결과 값을 반환(Deferred<T>)
  * await() 시점에 결과를 기다리며 suspend

## 코루틴의 중단과 재개
코루틴은 언제든 중단(suspend)되었다가 재개(resume)될 수 있다.
이때
* 재개 시 같은 스레드가 아닐 수도 있다.
  * 코루틴의 앞부분은 1번 스레드에서 실행되고 뒷부분은 2번 스레드에서 실행될 수 있다
* 즉 코루틴은 스레드에 종속되지 않으며 스레드는 단순히 코루틴을 실행해주는 실행기 역할을 한다

## suspend 함수와 컴파일러 동작
코틀린 컴파일러는 suspend가 붙은 함수에 추가적인 코드를 추가한다.
컴파일러는 다음과 같은 작업을 수행한다.

* 대상 함수에 Continuation 파라미터를 추가
* Continuation 구현체를 생성
* 함수 내부의 모든 suspend 지점에 동일한 Continuation 객체를 전달
* 코드를 분리해 state machine(FSM) 형태로 변환
  * switch / label 구조로 상태를 관리

코루틴은 내부적으로 FSM(Finite State Machine)기반으로 동작한다.
* 실행 중 suspend 지점에 도달하면 현재 상태(state)를 저장하고 중단
* 재개 시 저장된 state를 기준으로 다시 실행
* 모든 상태를 처리하면 최종 결과를 caller에게 반환
상태 기반 반복 실행되는 구조이다.
