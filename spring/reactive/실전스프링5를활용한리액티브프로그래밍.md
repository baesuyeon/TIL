> 참고: 실전 스프링5를 활용한 리액티브 프로그래밍

## 왜 반응성이 필요할까?
- 탄력성 : 다양한 작업 부하에서도 응답성을 유지하는 능력
  - 사용자가 많아져도 시스템 처리량이 자동으로 증가하여 평균 지연 시간에 영향을 미치지 않아야 한다
- **응답성(응답 능력)** : 요청에 빠르고 예측 가능한 시간안에 응답할 수 있는 능력
  - 수평적, 수직적 확장을 통해 처리량을 증가시킬 수 있다.
- 복원력 : 일부 시스템 장애에도 응답성을 유지할 수 있는 능력
  - 댓글 서비스에 장애가 발생하더라도 게시글 조회에는 아무런 영향없이 정상적으로 동작해야 한다

반응성은 단순히 빠른 속도가 아니라, 부하가 커져도, 장애가 일부 발생해도, 사용자가 기대하는 응답성을 유지하는 것이다.

일반적으로 분산 시스템에서 서비스 간에 통신할 때 자원을 효율적으로 사용하기 위해서는 **메시지 기반 통신** 원칙을 따라야 한다.
(일상 생활에서 문자 메시지를 보내면 보통 대답을 기다리지 않고 다른 일을 하면서 남은 시간을 효율적으로 활용할 수 있다.)
추가로 메세지 브로커를 사용하여 부하 및 탄력성을 제어할 수 있다.

이처럼 반응성, 복원력, 탄력성, 메시지 기반 통신이라는 특성은 단순한 프로그래밍 기법이 아니라 시스템 전체를 어떻게 설계하고 운영할 것인가에 대한 관점과 원칙이다.
즉 리액티브 시스템은 하나의 **아키텍처적 접근**이라고 할 수 있다. 구현을 위해 구체적인 기술을 도입할 수 있다.
리액티브 프로그래밍이란 리액티브 시스템의 설계 요구사항에 적합한 기술을 말한다.

* 주문 요청을 받자마자 응답을 보낸 후 비동기로 주문 처리(외부 시스템의 장애 발생 시 결제 요청을 재시도)
* 데이터베이스 복제 서비스를 활성화해 복제본 중 하나가 중단된 경우에도 복원력 유지

## 왜 리액티브 스프링인가?
의존하고 있는 서비스 클래스가 HTTP 요청이나 데이터베이스 쿼리와 같이 시간이 걸리는 I/O 작업을 실행한다고 가정할 때, 스레드가 차단될 수 있다.
독립적인 처리를 실행하기 위해 추가 스레드를 할당할 수 있지만 이는 낭비일 수 있다.

Java에서의 해결책
1. 콜백 기법
   1. +) 함수 호출 시, 작업 완료 후에 반응할 콜백 함수를 전달하는 방식이다. 별도의 Thread로 래핑하여 함수 호출 응답을 기다리지 않고 즉시 다른 작업을 진행할 수 있다.
   2. -) 콜백 지옥을 피하기 위해 개발자가 멀티 스레딩을 잘 이해하고 있어야 한다.
2. Future
   1. Future는 클래스 래퍼를 사용해 사용 가능한 결과가 있는지를 확인할 수 있다. (future.get())
   2. +) Future 구현 뒤에 멀티 스레드의 복잡성을 숨길 수 있다.
   3. -) 필요한 결과를 얻으려면 현재 스레드를 차단해야 한다.
3. CompletableFuture
   1. +) 논블로킹으로 콜백/조합/예외 처리까지 지원하는 Future의 업그레이드(단순히 결과를 기다리는 Future와 달리 함수형 스타일의 다양한 메서드를 제공한다)

참고)
* 동기/비동기는 "결과를 어떻게 알려주는가"의 개념
  * 동기 : 결과 받을 때까지 기다린다
  * 비동기 : 결과가 알림 방식으로 도착한다 (콜백/이벤트 기반)
* 블로킹/논블로킹은 "요청 스레드가 멈추는가"의 개념
  * 블로킹 : 친구에게 "내 신발끈 좀 묶어줄래?"라고 부탁했는데 그 친구가 신발끈을 다 묶을 때까지 나는 다른 일을 아무것도 못하고 서서 기다려야 하는 것.
  * 논블로킹 : 친구에게 "내 신발끈 좀 묶어줄래?"라고 부탁하고 나서, 나는 다른 일을 하는 것.

