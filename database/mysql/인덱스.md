데이터베이스 내부적으로 인덱스를 B+Tree 자료구조를 사용하여 구현한다.

## 이진 트리
키: 인덱스로 지정한 컬럼의 '값'

이진 트리는 각 노드가 하나의 키를 가지며
왼쪽 서브트리에는 항상 해당 노드의 키보다 작은 값들이
오른쪽 서브트리에는 항상 큰 값들이 위치한다.

키를 검색할 때는 트리의 루트 노드에서 시작하여
현재 노드의 키와 비교한 뒤 왼쪽 또는 오른쪽 자식 노드로 이동하며 탐색한다.
이 방식은 매 단계마다 탐색 범위를 절반으로 줄일 수 있어 효율적이다.

이 효율을 극대화하기 위해
2분할(이진) 구조가 아니라 3분할, 4분할처럼 한 노드가 여러 방향으로 분기되는 구조를 사용할 수 있다.
이렇게 하면 트리의 깊이가 낮아져 검색 공간을 더 빠르게 줄일 수 있다.

각 노드 내부에서 비교해야 하는 키의 개수는 늘어나지만,
데이터베이스 환경에서는 **키 비교 연산보다 노드를 디스크에서 읽어오는 비용이 훨씬 크기 때문에** 이 단점은 충분히 감수할 수 있다.

## B-Tree
B-트리는 하나의 노드가 여러 개의 키를 가질 수 있는 트리 구조이다.
각 노드는 자신이 가진 키의 개수보다 항상 하나 더 많은 자식 노드를 가진다.

노드가 다양한 방향으로 분기되기 때문에 트리의 높이가 낮아지고,
이진 트리에 비해 훨씬 적은 수의 노드만 접근해도 원하는 키를 찾을 수 있다.

B-트리에서 트리 구조가 한쪽으로 치우쳐 불균형해지는 것을 방지하기 위해 다음과 같은 규칙을 가진다.
* 모든 리프 노드는 항상 같은 레벨에 위치한다.
* 모든 노드는 최대 키 개수를 가진다. (루트 노드는 예외)
* 각 노드는 최소한 최대 키 개수 / 2 이상의 키를 유지한다.

이러한 제약을 통해 트리는 항상 균형을 유지하며
노드의 수가 많더라도 실제 검색 시에는 소수의 노드만 접근하면 된다.

### 범위 검색의 문제
특정 구간의 데이터를 모두 조회해야 하는 범위 검색의 경우 B-트리 구조는 비효율적일 수 있다.

하나의 키를 찾을 때마다 루트에서 다시 탐색을 시작해야 하며 이 과정에서 트리를 반복적으로 오르내리게 된다.
그 결과 디스크 I/O가 자주 발생하고, 불필요한 디스크 읽기가 많아진다.

## B+트리
B+트리는 이러한 범위 검색의 비효율을 개선하기 위해 등장한 구조이다.
* 실제 데이터(또는 데이터 포인터)는 모두 리프 노드에만 저장된다.
* 중간 노드에는 탐색을 위한 키만 저장된다.
* 모든 리프 노드는 연결 리스트 형태로 서로 연결되어 있다.

이 구조 덕분에 범위 검색 시 리프 노드를 따라 수평 스캔이 가능하며 연속적인 디스크 읽기를 통해 매우 효율적인 조회가 가능하다.

* 랜덤 I/O
  * 10쪽 → 200쪽 → 35쪽 → 410쪽 (디스크에서 가장 비싼 건 이동이다.)
* 순차 I/O
  * 100쪽을 펼치고 쭉 읽기, 100 → 101 → 102 → 103 …

## 클러스터드 / 넌클러스터드 인덱스
같은 B+Tree라도 리프 노드에 무엇을 두느냐에 따라 성능이 달라질 수 있다.

* 리프 노드가 실제 데이터를 들고 있는지
* 아니면 데이터 위치(포인터)만 들고 있는지

### 클러스터드 인덱스
**B+Tree 리프 = 실제 데이터**
* 리프 노드에 실제 레코드 row 전체가 들어있다.
* 테이블 자체가 하나의 B+Tree이다.
* 테이블 당 하나만 만들 수 있다.
* PK 기준으로 데이터가 물리적으로 정렬되어있다.

### 넌클러스터드 인덱스
**B+Tree 리프 = 포인터**
* 테이블 당 여러개를 만들 수 있다.
* 리프 노드에는 실제 데이터 대신 데이터를 찾아가기 위한 주소값이 들어있다.
  * MySQL InnoDB에서는 이 주소값으로 클러스터드 인덱스의 키(PK)를 사용한다. 
* 실제 데이터는 클러스터드 인덱스 트리에서 한번 더 찾아가야 하기 때문에 클러스터드보다 조금 느리다.

## 커버링 인덱스
```sql
WHERE age BETWEEN 20 AND 30
```

넌클러스터드 인덱스도 B+Tree로 구현되어있다.
리프 노드들이 서로 연결되어있어 인덱스 리프 노드를 쭉 수평으로 스캔한다. (순차 I/O)
넌클러스터드 인덱스 리프에는 보통 `(age, PK)`가 들어있다.
각 PK마다 클러스터드 인덱스 트리에서 탐색을 진행한다. (랜덤 I/O)

커버링 인덱스는 쿼리에 필요한 모든 컬럼이 인덱스에 이미 들어가있는것을 의미한다.
```sql
SELECT age, name
 FROM user
 WHERE age BETWEEN 20 AND 30;

(age, name, PK)  ← 인덱스
```
인덱스 리프 노트만 읽고 끝난다.
클러스터드 인덱스 탐색을 하지 않기 때문에 랜덤 I/O가 발생하지 않는다.

### ORDER BY, LIMIT
ORDER BY + 클러스터드 인덱스
```sql
SELECT *
 FROM posts
 ORDER BY id
 LIMIT 10;
```
id = PK = 클러스터드 인덱스 기준
이미 정렬되어있기 때문에 리프 노드부터 앞에서 10개만 읽고 끝나게된다.

ORDER BY + 넌 클러스터드 인덱스 (커버링 X)
```sql
SELECT *
 FROM posts
 ORDER BY created_at
 LIMIT 10;
 
(created_at) ← 인덱스
```
created_at 기준 정렬되어있는 인덱스 리프에는 `(created_at, PK)`가 저장되어있다.
하지만 `SELECT *` 때문에 LIMIT 10이어도 랜덤 I/O가 10번 발생하게된다.

ORDER BY + 넌 클러스터드 인덱스 (커버링 O)
```text
SELECT id, created_at
 FROM posts
 ORDER BY created_at
 LIMIT 10;
```
인덱스 리프만 읽으면 된다.