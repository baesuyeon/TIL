데이터베이스 내부적으로 인덱스를 B+Tree 자료구조를 사용하여 구현한다.

## 이진 트리
키: 인덱스로 지정한 컬럼의 '값'

이진 트리는 각 노드가 하나의 키를 가지며
왼쪽 서브트리에는 항상 해당 노드의 키보다 작은 값들이
오른쪽 서브트리에는 항상 큰 값들이 위치한다.

키를 검색할 때는 트리의 루트 노드에서 시작하여
현재 노드의 키와 비교한 뒤 왼쪽 또는 오른쪽 자식 노드로 이동하며 탐색한다.
이 방식은 매 단계마다 탐색 범위를 절반으로 줄일 수 있어 효율적이다.

이 효율을 극대화하기 위해
2분할(이진) 구조가 아니라 3분할, 4분할처럼 한 노드가 여러 방향으로 분기되는 구조를 사용할 수 있다.
이렇게 하면 트리의 깊이가 낮아져 검색 공간을 더 빠르게 줄일 수 있다.

각 노드 내부에서 비교해야 하는 키의 개수는 늘어나지만,
데이터베이스 환경에서는 **키 비교 연산보다 노드를 디스크에서 읽어오는 비용이 훨씬 크기 때문에** 이 단점은 충분히 감수할 수 있다.

## B-Tree
B-트리는 하나의 노드가 여러 개의 키를 가질 수 있는 트리 구조이다.
각 노드는 자신이 가진 키의 개수보다 항상 하나 더 많은 자식 노드를 가진다.

노드가 다양한 방향으로 분기되기 때문에 트리의 높이가 낮아지고,
이진 트리에 비해 훨씬 적은 수의 노드만 접근해도 원하는 키를 찾을 수 있다.

B-트리에서 트리 구조가 한쪽으로 치우쳐 불균형해지는 것을 방지하기 위해 다음과 같은 규칙을 가진다.
* 모든 리프 노드는 항상 같은 레벨에 위치한다.
* 모든 노드는 최대 키 개수를 가진다. (루트 노드는 예외)
* 각 노드는 최소한 최대 키 개수 / 2 이상의 키를 유지한다.

이러한 제약을 통해 트리는 항상 균형을 유지하며
노드의 수가 많더라도 실제 검색 시에는 소수의 노드만 접근하면 된다.

### 범위 검색의 문제
특정 구간의 데이터를 모두 조회해야 하는 범위 검색의 경우 B-트리 구조는 비효율적일 수 있다.

하나의 키를 찾을 때마다 루트에서 다시 탐색을 시작해야 하며 이 과정에서 트리를 반복적으로 오르내리게 된다.
그 결과 디스크 I/O가 자주 발생하고, 불필요한 디스크 읽기가 많아진다.

## B+트리
B+트리는 이러한 범위 검색의 비효율을 개선하기 위해 등장한 구조이다.
* 실제 데이터(또는 데이터 포인터)는 모두 리프 노드에만 저장된다.
* 중간 노드에는 탐색을 위한 키만 저장된다.
* 모든 리프 노드는 연결 리스트 형태로 서로 연결되어 있다.

이 구조 덕분에 범위 검색 시 리프 노드를 따라 수평 스캔이 가능하며 연속적인 디스크 읽기를 통해 매우 효율적인 조회가 가능하다.

* 랜덤 I/O
  * 10쪽 → 200쪽 → 35쪽 → 410쪽 (디스크에서 가장 비싼 건 이동이다.)
* 순차 I/O
  * 100쪽을 펼치고 쭉 읽기, 100 → 101 → 102 → 103 …

## 클러스터드 / 넌클러스터드 인덱스
같은 B+Tree라도 리프 노드에 무엇을 두느냐에 따라 성능이 달라질 수 있다.

* 리프 노드가 실제 데이터를 들고 있는지
* 아니면 데이터 위치(포인터)만 들고 있는지

### 클러스터드 인덱스
**B+Tree 리프 = 실제 데이터**
* 리프 노드에 실제 레코드 row 전체가 들어있다.
* 테이블 자체가 하나의 B+Tree이다.
* 테이블 당 하나만 만들 수 있다.
* PK 기준으로 데이터가 물리적으로 정렬되어있다.

### 넌클러스터드 인덱스
**B+Tree 리프 = 포인터**
* 테이블 당 여러개를 만들 수 있다.
* 리프 노드에는 실제 데이터 대신 데이터를 찾아가기 위한 주소값이 들어있다.
  * MySQL InnoDB에서는 이 주소값으로 클러스터드 인덱스의 키(PK)를 사용한다. 
* 실제 데이터는 클러스터드 인덱스 트리에서 한번 더 찾아가야 하기 때문에 클러스터드보다 조금 느리다.

## 커버링 인덱스
```sql
WHERE age BETWEEN 20 AND 30
```

넌클러스터드 인덱스도 B+Tree로 구현되어있다.
리프 노드들이 서로 연결되어있어 인덱스 리프 노드를 쭉 수평으로 스캔한다. (순차 I/O)
넌클러스터드 인덱스 리프에는 보통 `(age, PK)`가 들어있다.
각 PK마다 클러스터드 인덱스 트리에서 탐색을 진행한다. (랜덤 I/O)

커버링 인덱스는 쿼리에 필요한 모든 컬럼이 인덱스에 이미 들어가있는것을 의미한다.
```sql
SELECT age, name
 FROM user
 WHERE age BETWEEN 20 AND 30;

(age, name, PK)  ← 인덱스
```
인덱스 리프 노트만 읽고 끝난다.
클러스터드 인덱스 탐색을 하지 않기 때문에 랜덤 I/O가 발생하지 않는다.

### ORDER BY, LIMIT
ORDER BY + 클러스터드 인덱스
```sql
SELECT *
 FROM posts
 ORDER BY id
 LIMIT 10;
```
id = PK = 클러스터드 인덱스 기준
이미 정렬되어있기 때문에 리프 노드부터 앞에서 10개만 읽고 끝나게된다.

ORDER BY + 넌 클러스터드 인덱스 (커버링 X)
```sql
SELECT *
 FROM posts
 ORDER BY created_at
 LIMIT 10;
 
(created_at) ← 인덱스
```
created_at 기준 정렬되어있는 인덱스 리프에는 `(created_at, PK)`가 저장되어있다.
하지만 `SELECT *` 때문에 LIMIT 10이어도 랜덤 I/O가 10번 발생하게된다.

ORDER BY + 넌 클러스터드 인덱스 (커버링 O)
```text
SELECT id, created_at
 FROM posts
 ORDER BY created_at
 LIMIT 10;
```
인덱스 리프만 읽으면 된다.

## 인덱스 특징
인덱스를 생성할 때마다 DB 용량이 늘어난다.
원본 DB에 삽입/삭제가 발생할때마다 인덱스에도 반영해줘야하기 때문에 삽입/삭제 성능이 낮아질 수 있다.
테이블이 작은 경우에는 인덱스를 안쓰는것이 낫다.

## 복합 인덱스
복합 인덱스를 만들 때 
* WHERE에 자주 사용되는 컬럼을 앞쪽에 둔다.
* 자주 단독으로 조회되는 컬럼은 왼쪽에 둔다.
* range 조건은 뒤에 두고 ORDER BY에 맞춘다.
* 더 많이 필터링하
자주 단독으로 조회되는 컬럼을 앞에 두는 것이 좋다. (range 조건은 뒤에 두고 ORDER BY에 맞추기)


복합 인덱스를 사용할 때 ORDER BY의 방향(ASC/DESC)을 인덱스 정렬 방향과 맞추는 것이 중요하다.
두개 이상의 컬럼을 서로 다른 방향으로 정렬해야 할 때는 반드시 인덱스 생성시 그 방향을 명시해야 한다.

예시) 최신 등록일 순(DESC)으로 보되, 등록일이 같다면 가격이 낮은 순(ASC)으로 보여줘야하는 경우
쿼리: SELECT * FROM products ORDER BY created_at DESC, price ASC;
인덱스: CREATE INDEX idx_created_price ON products (created_at ASC, price ASC);
인덱스를 단순히 앞에서부터 읽거나 뒤에서부터 읽는 방식으로는 쿼리의 요구사항을 만족시킬 수 없다.

필요한 인덱스: CREATE INDEX idx_created_price ON products (created_at DESC, price ASC); 

인덱스를 뒤에서부터 읽는 역방향 스캔은 정방향 스캔보다 약 15%~30% 정도 더 느리다. (EXPLAIN 결과 → Backward index scan)
뒤에서부터 10개를 찾는 과정이 정방향으로 10개를 찾는 것보다 자원을 많이 소모한다. 
`ORDER BY DESC LIMIT` 쿼리가 자주 호출되는 경우 인덱스 자체를 DESC로 만드는 것도 고려할 수 있다.

`LIMIT 20` 이 있다고해서 읽는 데이터가 줄어드는 것은 아니다. (스캔량을 줄여주지는 않는다)
남 50%, 여 50% 데이터가 존재하는 상황

```sql
SELECT *
  FROM user
  WHERE gender = '남'
  ORDER BY id DESC
  LIMIT 20;
```
- 인덱스가 없는 경우
1. 테이블을 전체 스캔하여 gender = '남' row를 필터링한다.
2. 필터링 한 결과를 정렬한다.
3. 20개를 반환한다.
   → 50% 데이터를 읽게된다 (대부분의 데이터)

- gender 인덱스만 있는 경우
1. 인덱스를 통해 gender = '남' row를 찾는다.
2. 50% 후보의 PK(id)를 읽어서 id 상위 20개를 찾는다.
3. 상위 20개 각 row에 대해 클러스터드 인덱스로 다시 탐색한다.
   → 50% 데이터를 읽게된다 (대부분의 데이터)
   → 옵티마이저가 차라리 테이블 풀스캔하고 정렬하는 게 더 낫겠다고 판단할 수도 있다.

- (gender, id) 복합 인덱스가 있는 경우
1. 인덱스를 통해 gender = '남' row를 찾는다.
2. 이미 id desc 정렬된 상태라 위에서부터 20개만 읽고 종료한다.

### 인덱스의 핵심은 무엇인가? 선별력이다.
인덱스의 존재 이유는 전체 중 얼마나 적게 걸러낼 수 있느냐이다.

```text
선별력 = 조건에 해당하는 row 수 / 전체 row 수
```
* 값이 작을수록 좋다 (예: 5%)
* 값이 클수록 의미가 없다 (예: 50%)

카디널리티란? 컬럼에 존재하는 서로 다른 값의 개수이다.
| 컬럼      | 값 분포            | 카디널리티 |
| ------- | --------------- | ----- |
| 성별      | 남/여             | 낮음    |
| 상태      | ACTIVE/INACTIVE | 낮음    |
| user_id | 거의 모두 다름        | 매우 높음 |

카디널리티가 높을 수록 선별력이 낮아진다. -> 좋다.
`gender` (남/여 50%/50%)에 단독 인덱스를 걸면 후보가 너무 많아서 풀스캔이 더 빠를 가능성이 크다.

그럼 선택도가 낮은 컬럼은 무조건 인덱스를 걸지 않는것이 맞을까?
(1) 소수값을 자주 조회하는 케이스에는 유용하다.
`WHERE on_hide = true` 

(2) 복합 인덱스에서는 효율이 좋을 수 있다.
```sql
WHERE gender = '남'
ORDER BY id DESC
LIMIT 20

INDEX(gender, created_at DESC)
```
위 예시 설명 참고

(3) 다른 조건과 함께 쓰일 때 효율이 좋을 수 있다.
```sql
WHERE gender='남'
AND city='서울'
```
각각은 선택도가 낮지만 결합시 결과가 적어져서 인덱스에 유리해질 수 있다.
